# -*- coding: utf-8 -*-
"""Indian Cars : Data Processing and Visualization

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1y5YHyfHcnFIbZF9wLz6Ch17pPLR2ou2M

#**Week-6 Assignment-1**
##**Indian Cars: Data Processing & Visualization**
### *By Arijit Dhali [Linkedin](https://www.linkedin.com/in/arijit-dhali-b255b0138/)*
---
Around 3.34 Lakh passenger cars were sold in the Indian market in May 2023. The sales increased by over 13% when compared to May last year. The Top 25 Selling Cars constituted over 75% of the cars sold in April 2023.

This dataset consists of 141 columns. Performing Exploratory Data analysis on this dataset. Document the findings and insights using proper graphs to represent the data.

We need to perform Univariate and Bivariate analysis for the given dataset. Below are the steps you can follow for both univariate and bivariate analysis of the dataset.

### Note: This following notebooks deals with **Data Processing**

# **Importing Libraries**

So, inorder to perform anything on the data we must require to import the librarires first and set the diplay view of the dataset.

This code snippet imports necessary Python libraries, `sets display options for Pandas`, and prepares the environment for data analysis and visualization.
"""

# Importing required libraries for data analysis and visualization
import pandas as pd                       # Pandas for data manipulation and analysis
import numpy as np                        # NumPy for numerical operations
import matplotlib.pyplot as plt           # Matplotlib for basic plotting
import seaborn as sns                     # Seaborn for statistical data visualization
import plotly.express as px               # Plotly Express for interactive visualizations

# Setting display options for Pandas to show three decimal places for floating-point numbers
pd.set_option('display.float_format', lambda x: '%.3f' % x)

"""# **Loading Dataset**

After importing librarires, we will import the data using `GitHub` link of raw file

Continuing the setup for data analysis by adjusting `Pandas display options` and then loads a dataset from a `URL` into a `Pandas` DataFrame.
"""

# Display all columns without truncation
pd.set_option('display.max_columns', None)

# Load car-related dataset from URL into 'car' DataFrame
url = 'https://raw.githubusercontent.com/ArijitDhali/PrepInsta-DA-Week-6/main/cars_ds_final.csv'
car = pd.read_csv(url, encoding='unicode_escape')

# Display first two rows of the loaded DataFrame
car.head(2)

"""The code deletes the 'Unnamed: 0' column from the `'car'` DataFrame, likely an unnecessary index. <br>The `head(2)` function then displays the first two rows of the updated DataFrame.


"""

# Remove 'Unnamed: 0' column from 'car' DataFrame
del car["Unnamed: 0"]

# Display first two rows
car.head(2)

"""# **Preliminary Data Inspection**

To perform any operation on the dataset, we need to get familiarized with the dataset.

Showcasing the data types of each column in the '`car`' DataFrame.
"""

car.dtypes        # Display data types of columns in the 'car' DataFrame

"""Detailed information about the '`car`' DataFrame, including *data types* and *memory usage*"""

car.info(verbose=True)        # Display concise information about 'car' DataFrame

"""Showing the number of rows and columns"""

car.shape         # Display the shape (rows, columns)

"""Using `car.describe()` to generate descriptive statistics for the numerical columns in the '`car`' DataFrame."""

car.describe()      # Generate descriptive statistics for numerical columns

"""# **Data Cleaning and Trimming**

Modifying each and every column accordingly to get a smooth analysis in data vizualization.

### 1. Handling the large missing values

Now, we will calculate and display the percentage of missing values for each column in the '`car`' DataFrame. <br>This information helps in understanding the completeness of the dataset and identifies columns with **missing data**.
"""

# Calculate the percentage of missing values for each column in 'car' DataFrame
row_size = car.shape[0]
for i in car.columns:
    if car[i].isnull().sum() > 0:
        print(i, "----------", (car[i].isnull().sum() / row_size) * 100)

""" checking for and printing the number of duplicate rows in the '`car`' DataFrame, helping to identify and address potential data duplication issues."""

# Check for duplicate rows in 'car' DataFrame
car.duplicated().sum()

"""Remove the duplicate rows from the '`car`' DataFrame"""

# Drop duplicate rows from the 'car' DataFrame
car = car.drop_duplicates()
car.duplicated().sum()

"""Now we will observe the current `shape` of the '`car`' DataFrame, indicating the number of rows and columns after the previous operations."""

car.shape         # Display the current shape (rows, columns) of the 'car' DataFrame

"""In this step, we now remove columns from the '`car`' DataFrame that have more than **70% missing values**, excluding the '`ARAI_Certified_Mileage_for_CNG`' column for future reference."""

# Remove columns with more than 70% missing values, excluding 'ARAI_Certified_Mileage_for_CNG'
row_size = car.shape[0]
for i in car.columns:
    if i != 'ARAI_Certified_Mileage_for_CNG':
        if car[i].isnull().sum() * 100 / row_size > 70:
            car.drop(columns=[i], inplace=True)

"""Now, we observe the shape of the '`car`' DataFrame **after removing** columns with more than 70% missing values (excluding '`ARAI_Certified_Mileage_for_CNG`')."""

car.shape                 # Display the updated shape (rows, columns) of the 'car' DataFrame

"""### 2. Processing `Make`, `Model` and `Variant` Dataset

Here, we fill the missing values in the '`Make`' column with the corresponding values from the '`Model`' column, updating the '`car`' DataFrame in place.
"""

# Fill missing values in 'Make' column with corresponding 'Model' values
car['Make'].fillna(car['Model'], inplace=True)

"""Now, we inspect the unique values in the '`Make`' column of the '`car`' DataFrame to understand the variety of car makes present in the dataset."""

car['Make'].unique()                        # Display unique values in the 'Make' column of the 'car' DataFrame

"""Here, we standardize the '`Make`' values in the '`car`' DataFrame by **replacing or updating** specific entries for consistency. This ensures a uniform representation of car makes in the dataset."""

# Standardize 'Make' values in the 'car' DataFrame
car.loc[car['Make'].str.contains('Mercedes-Benz', na=False), 'Make'] = 'Mercedes-Benz'
car.loc[car['Make'].str.contains('Rolls-Royce', na=False), 'Make'] = 'Rolls-Royce'
car.loc[car['Make'].str.contains('Go+', na=False), 'Make'] = 'Datsun'
car.loc[car['Make'].str.contains('Maruti Suzuki R', na=False), 'Make'] = 'Maruti Suzuki'
car['Make'] = car['Make'].str.replace('Land Rover Rover', 'Land Rover')

"""Now, we examine the unique values in the updated '`Make`' column of the '`car`' DataFrame to verify the standardization and consistency applied to the car makes."""

car['Make'].unique()            # Display unique values in the updated 'Make' column of the 'car' DataFrame

"""In this step, we refine and update specific values in the '`Make`', '`Model`', and '`Variant`' columns of the '`car`' DataFrame for consistency and clarity."""

# Update 'Make', 'Model', and 'Variant' values in the 'car' DataFrame
car.loc[car['Make'].str.contains('Wagon', na=False), 'Make'] = 'Wagon R'
car['Model'] = car['Model'].str.replace('Wagon', 'Wagon R')
car['Model'] = car['Model'].str.replace('Mercedes-Benz ', '')
car['Model'] = car['Model'].str.replace('Rolls-Royce ', '')
car['Variant'] = car['Variant'].str.replace('Datsun ', '')

"""Now, we take a look at a random sample of 5 rows from the '`car`' DataFrame to get an overview of the data after the previous transformations."""

car.sample(5)                   # Display a random sample of 5 rows from the 'car' DataFrame

"""### 3. Processing `Ex-Showroom_Price` and `Displacement` Dataset

Here, we print the first few rows of specific columns, '`Ex-Showroom_Price`' and '`Displacement`', from the 'car' DataFrame.
"""

# Display specific columns 'Ex-Showroom_Price' and 'Displacement' from the 'car' DataFrame
specific_1 = ['Ex-Showroom_Price','Displacement']
print(car[specific_1].head())

"""Here, we clean the '`Ex-Showroom_Price`' column by removing **non-numeric** characters, rename it to '`Ex-Showroom_Price_INR`', and convert the values to **integers** in the '`car`' DataFrame."""

# Clean 'Ex-Showroom_Price' column in 'car' DataFrame
car['Ex-Showroom_Price'] = car['Ex-Showroom_Price'].replace(r'\D', '', regex=True)

# Rename the cleaned column to 'Ex-Showroom_Price_INR'
car.rename(columns={'Ex-Showroom_Price': 'Ex-Showroom_Price_INR'}, inplace=True)

# Convert 'Ex-Showroom_Price_INR' column to integer type
car['Ex-Showroom_Price_INR'] = car['Ex-Showroom_Price_INR'].astype(int)

"""This code cleans the '`Displacement`' column by **removing non-numeric** characters, renames it to '`Displacement_cc`', and converts the values to **float** in the '`car`' DataFrame."""

# Clean 'Displacement' column in 'car' DataFrame
car['Displacement'] = car['Displacement'].replace(r'\D', '', regex=True)

# Rename the cleaned column to 'Displacement_cc'
car.rename(columns={'Displacement': 'Displacement_cc'}, inplace=True)

# Convert 'Displacement_cc' column to float type
car['Displacement_cc'] = car['Displacement_cc'].astype(float)

"""Here, we print the first few rows of specific columns, '`Ex-Showroom_Price_INR`' and '`Displacement_cc`', from the '`car`' DataFrame to check the cleaning clarity."""

# Display specific columns 'Ex-Showroom_Price_INR' and 'Displacement_cc' from the 'car' DataFrame
specific_1 = ['Ex-Showroom_Price_INR', 'Displacement_cc']
print(car[specific_1].head())

"""###4. Ensuring Datatypes of `Cylinders` and `Valves_Per_Cylinder` Dataset

Here, we convert the '`Cylinders`' and '`Valves_Per_Cylinder`' column to float type in the '`car`' DataFrame.
"""

car['Cylinders'] = car['Cylinders'].astype(float)               # Convert 'Cylinders' column to float type in 'car' DataFrame

car['Valves_Per_Cylinder'] = car['Valves_Per_Cylinder'].astype(float)       # Convert 'Valves_Per_Cylinder' column to float type in 'car' DataFrame

"""###5. Processing `Drivetrain` Dataset

Now, we examine the unique values in the '`Drivetrain`' column of the '`car`' DataFrame to understand the different drivetrain configurations present in the dataset.
"""

car['Drivetrain'].unique()                        # Display unique values in the 'Drivetrain' column of the 'car' DataFrame

"""This code cleans the '`Drivetrain`' column in the '`car`' DataFrame by removing specific patterns like '`(Rear Wheel Drive)`', '`(Front Wheel Drive)`', and '`(All Wheel Drive)`'."""

# Clean 'Drivetrain' column in 'car' DataFrame
car['Drivetrain'] = car['Drivetrain'].str.replace(r'\(Rear Wheel Drive\)', '', regex=True)
car['Drivetrain'] = car['Drivetrain'].str.replace(r'\(Front Wheel Drive\)', '', regex=True)
car['Drivetrain'] = car['Drivetrain'].str.replace(r'\(All Wheel Drive\)', '', regex=True)

"""Now, we inspect the unique values in the cleaned '`Drivetrain`' column of the '`car`' DataFrame to observe the drivetrain configurations after the cleaning process."""

car['Drivetrain'].unique()                    # Display unique values in the cleaned 'Drivetrain' column of the 'car' DataFrame

"""###6. Processing `Emission_Norm` and `Engine_Location` Dataset

Here, we observe the unique values in the '`Emission_Norm`' column of the '`car`' DataFrame to understand the different emission norms present in the dataset.
"""

car['Emission_Norm'].unique()       # Display unique values in the 'Emission_Norm' column of the 'car' DataFrame

"""In this step, we replace '`BS 6`' with '`BS VI`' in the '`Emission_Norm`' column of the '`car`' DataFrame for consistency."""

car['Emission_Norm'] = car['Emission_Norm'].str.replace('BS 6', 'BS VI')    # Update 'Emission_Norm', replacing 'BS 6' with 'BS VI'

"""Now, we examine the unique values in the updated '`Emission_Norm`' column of the '`car`' DataFrame to confirm the replacement of '`BS 6`' with '`BS VI`'."""

car['Emission_Norm'].unique()       # Display unique values in the updated 'Emission_Norm' column of the 'car' DataFrame

"""Here, we explore the unique values in the '`Engine_Location`' column of the '`car`' DataFrame to understand the various engine locations recorded in the dataset."""

car['Engine_Location'].unique()       # Display unique values in the 'Engine_Location' column of the 'car' DataFrame

"""This code modifies the '`Engine_Location`' column in the '`car`' DataFrame by replacing '`, `' with '` - `' for consistency and clarity."""

car['Engine_Location'] = car['Engine_Location'].str.replace(', ', ' - ')    # Update 'Engine_Location' replacing ', ' with ' - '

"""Now, we examine the unique values in the updated '`Engine_Location`' column of the '`car`' DataFrame after the replacement operation."""

car['Engine_Location'].unique()     # Display unique values in the updated 'Engine_Location' column of the 'car' DataFrame

"""###7. Processing `Fuel_Tank_Capacity`, `Height`, `Length`, `Width`, `Kerb_Weight` and `Ground_Clearance` Dataset

Here, we print the first few rows of the '`Fuel_Tank_Capacity`' column from the '`car`' DataFrame to inspect the fuel tank capacity values.
"""

# Display the 'Fuel_Tank_Capacity' column from the 'car' DataFrame
fuel = ['Fuel_Tank_Capacity']
print(car[fuel].head())

"""This code cleans the '`Fuel_Tank_Capacity`' column by removing non-numeric characters, renames it to '`Fuel_Tank_Capacity_litres`', and converts the values to **float** in the '`car`' DataFrame."""

# Clean 'Fuel_Tank_Capacity' column in 'car' DataFrame
car['Fuel_Tank_Capacity'] = car['Fuel_Tank_Capacity'].replace(r'\D', '', regex=True)

# Rename the cleaned column to 'Fuel_Tank_Capacity_litres'
car.rename(columns={'Fuel_Tank_Capacity': 'Fuel_Tank_Capacity_litres'}, inplace=True)

# Convert 'Fuel_Tank_Capacity_litres' column to float type
car['Fuel_Tank_Capacity_litres'] = car['Fuel_Tank_Capacity_litres'].astype(float)

"""Now, we print the first few rows of the cleaned '`Fuel_Tank_Capacity_litres`' column from the '`car`' DataFrame to inspect the fuel tank capacity values after the cleaning process."""

# Display the cleaned 'Fuel_Tank_Capacity_litres' column from the 'car' DataFrame
fuel = ['Fuel_Tank_Capacity_litres']
print(car[fuel].head())

"""Here, we print the first few rows of selected dimensions ('`Height`', '`Length`', '`Width`', '`Kerb_Weight`', '`Ground_Clearance`') from the '`car`' DataFrame for inspection."""

# Display selected dimensions - 'Height', 'Length', 'Width', 'Kerb_Weight', 'Ground_Clearance'
dimension = ['Height', 'Length', 'Width', 'Kerb_Weight', 'Ground_Clearance']
print(car[dimension].head())

"""This code cleans and standardizes various dimensions columns in the '`car`' DataFrame, renaming columns to reflect units and converting them to float type for consistency."""

# Clean and standardize dimensions in 'car' DataFrame
car['Height'] = car['Height'].replace(r'\D', '', regex=True)
car['Length'] = car['Length'].replace(r'\D', '', regex=True)
car['Width'] = car['Width'].replace(r'\D', '', regex=True)
car['Kerb_Weight'] = car['Kerb_Weight'].replace(r'\D', '', regex=True)
car['Ground_Clearance'] = car['Ground_Clearance'].replace(r'\D', '', regex=True)

# Rename columns to reflect units and data type
car.rename(columns={'Height': 'Height_mm','Length': 'Length_mm','Width': 'Width_mm'}, inplace=True)
car.rename(columns={'Kerb_Weight': 'Kerb_Weight_kg','Ground_Clearance':'Ground_Clearance_mm'}, inplace=True)

# Convert cleaned columns to float type
car['Height_mm'] = car['Height_mm'].astype(float)
car['Length_mm'] = car['Length_mm'].astype(float)
car['Width_mm'] = car['Width_mm'].astype(float)
car['Kerb_Weight_kg'] = car['Kerb_Weight_kg'].astype(float)
car['Ground_Clearance_mm'] = car['Ground_Clearance_mm'].astype(float)

"""Here, we display the cleaned and standardized dimensions ('`Height_mm`', '`Length_mm`', '`Width_mm`', '`Kerb_Weight_kg`', '`Ground_Clearance_mm`') from the '`car`' DataFrame for initial inspection."""

# Display cleaned and standardized dimensions from the 'car' DataFrame
dimension = ['Height_mm', 'Length_mm', 'Width_mm', 'Kerb_Weight_kg', 'Ground_Clearance_mm']
car[dimension].head()

"""###8. Processing `Body_Type`, `Gears`, and `Body_Type` Dataset

Now, we explore the unique values in the '`Body_Type`' column of the '`car`' DataFrame to understand the different types of car bodies recorded in the dataset.
"""

car['Body_Type'].unique()               # Display unique values in the 'Body_Type' column of the 'car' DataFrame

"""Here, we show the count of each unique value in the '`Gears`' column of the '`car`' DataFrame, providing insights into the distribution of gear types in the dataset."""

car['Gears'].value_counts()                 # Display the count of each unique value in the 'Gears' column of the 'car' DataFrame

"""This code updates and converts the '`Gears`' column in the '`car`' DataFrame, replacing specific values and converting the column to float type. <br>The count of each unique value in the updated '`Gears`' column is then displayed."""

# Update and convert 'Gears' column in 'car' DataFrame
car['Gears'] = car['Gears'].replace({'Single Speed Reduction Gear': '1', '7 Dual Clutch': '7'})
car['Gears'] = car['Gears'].astype(float)

# Display the count of each unique value in the updated 'Gears' column
car['Gears'].value_counts()

"""This code modifies the 'Body_Type' column in the 'car' DataFrame by replacing ', ' with '-' for consistency and clarity."""

car['Body_Type'] = car['Body_Type'].str.replace(', ', '-')          # Update 'Body_Type', replacing ', ' with '-'

"""Now, we examine the unique values in the updated '`Body_Type`' column of the '`car`' DataFrame after the replacement operation."""

car['Body_Type'].unique()                 # Display unique values in the updated 'Body_Type' column of the 'car' DataFrame

"""###9. Processing `Mileage` Datasets

Here, we count the number of missing values in the '`ARAI_Certified_Mileage`' column of the '`car`' DataFrame to assess the extent of missing mileage information.
"""

# Count the number of missing values in the 'ARAI_Certified_Mileage' column of the 'car' DataFrame
car['ARAI_Certified_Mileage'].isnull().sum()

"""This code fills missing values in the '`ARAI_Certified_Mileage`' column with the corresponding '`Highway_Mileage`' values for **non-CNG vehicles** in the '`car`' DataFrame."""

# Fill missing values in 'ARAI_Certified_Mileage' with 'Highway_Mileage' for non-CNG vehicles in 'car' DataFrame
car.loc[car['Fuel_Type'] != 'CNG', 'ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].fillna(car['Highway_Mileage'])

"""Now, we verify the number of missing values in the '`ARAI_Certified_Mileage`' column of the '`car`' DataFrame after the fill operation."""

# Re-check the number of missing values in the 'ARAI_Certified_Mileage' column of the 'car' DataFrame
car['ARAI_Certified_Mileage'].isnull().sum()

"""Here, we explore the unique values in the '`ARAI_Certified_Mileage`' column of the '`car`' DataFrame to understand the variety of ARAI certified mileage values present in the dataset."""

car['ARAI_Certified_Mileage'].unique()              # Display unique values in the 'ARAI_Certified_Mileage' column of the 'car' DataFrame

"""This code cleans and standardizes the '`ARAI_Certified_Mileage`' column in the '`car`' DataFrame, addressing units and replacing specific incorrect values. <br>The cleaned column is then renamed to '`ARAI_Certified_Mileage_kmpl`'."""

# Clean and standardize 'ARAI_Certified_Mileage' column in 'car' DataFrame
car['ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].str.replace(r'\s*km/litre', '', regex=True)
car['ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].str.replace('9.8-10.0', '10.0')
car['ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].str.replace('22.4-21.9', '22.4')
car['ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].str.replace(r'\s*kmpl', '', regex=True)

car['ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].astype(float)

# Replace specific incorrect values
car['ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].replace(142.0, 14.2)
car['ARAI_Certified_Mileage'] = car['ARAI_Certified_Mileage'].replace(1449.0, 14.49)

# Rename the cleaned column to 'ARAI_Certified_Mileage_kmpl'
car.rename(columns={'ARAI_Certified_Mileage': 'ARAI_Certified_Mileage_kmpl'}, inplace=True)

"""Now, we explore the unique values in the cleaned '`ARAI_Certified_Mileage_kmpl`' column of the '`car`' DataFrame to observe the standardized ARAI certified mileage values."""

car['ARAI_Certified_Mileage_kmpl'].unique()                   # Display unique values in the cleaned 'ARAI_Certified_Mileage_kmpl'

"""Here, we inspect the unique values in the '`ARAI_Certified_Mileage_for_CNG`' column of the '`car`' DataFrame to understand the ARAI certified mileage values for CNG-powered vehicles."""

# Display unique values in the 'ARAI_Certified_Mileage_for_CNG' column of the 'car' DataFrame
car['ARAI_Certified_Mileage_for_CNG'].unique()

"""This code cleans and standardizes the '`ARAI_Certified_Mileage_for_CNG`' column in the '`car`' DataFrame, addressing units. The cleaned column is then renamed to '`ARAI_Certified_Mileage_for_CNG_kmpkg`'."""

# Clean and standardize 'ARAI_Certified_Mileage_for_CNG' column in 'car' DataFrame
car['ARAI_Certified_Mileage_for_CNG'] = car['ARAI_Certified_Mileage_for_CNG'].str.replace(r'\s*km/kg', '', regex=True)
car['ARAI_Certified_Mileage_for_CNG'] = car['ARAI_Certified_Mileage_for_CNG'].astype(float)

# Rename the cleaned column to 'ARAI_Certified_Mileage_for_CNG_kmpkg'
car.rename(columns={'ARAI_Certified_Mileage_for_CNG': 'ARAI_Certified_Mileage_for_CNG_kmpkg'}, inplace=True)

"""Now, we explore the unique values in the cleaned '`ARAI_Certified_Mileage_for_CNG_kmpkg`' column of the '`car`' DataFrame to observe the standardized ARAI certified mileage values for CNG-powered vehicles."""

car['ARAI_Certified_Mileage_for_CNG_kmpkg'].unique()  # Display unique values in the cleaned 'ARAI_Certified_Mileage_for_CNG_kmpkg'

"""This line of code fills missing values in the '`ARAI_Certified_Mileage_kmpl`' column with values from the corresponding '`ARAI_Certified_Mileage_for_CNG_kmpkg`' column in the 'car' DataFrame."""

# Fill missing values in 'ARAI_Certified_Mileage_kmpl' with values from 'ARAI_Certified_Mileage_for_CNG_kmpkg'
car['ARAI_Certified_Mileage_kmpl'].fillna(car['ARAI_Certified_Mileage_for_CNG_kmpkg'], inplace=True)

"""This code removes the '`City_Mileage`', `'ARAI_Certified_Mileage_for_CNG_kmpkg'` and '`Highway_Mileage`' columns from the '`car`' DataFrame, as they are no longer needed."""

# Drop columns 'City_Mileage' and 'Highway_Mileage' from 'car' DataFrame
mileage_drop = ['City_Mileage', 'Highway_Mileage','ARAI_Certified_Mileage_for_CNG_kmpkg']
car.drop(columns=mileage_drop, inplace=True)

"""###10. Processing `Suspension` Datasets

Here, we examine the unique values in the '`Front_Suspension`' column of the '`car`' DataFrame to understand the different front suspension configurations recorded in the dataset.
"""

car['Front_Suspension'].unique()          # Display unique values in the 'Front_Suspension' column of the 'car' DataFrame

"""This code updates the '`Front_Suspension`' column in the '`car`' DataFrame, standardizing various suspension types for consistency and clarity."""

# Update 'Front_Suspension' column in 'car' DataFrame with standardized suspension types
car.loc[car['Front_Suspension'].str.contains('MacPherson|Mac Pherson|Mc Pherson|McPherson|Macpherson|Mcpherson', na=False), 'Front_Suspension'] = 'MacPherson Suspension'
car.loc[car['Front_Suspension'].str.contains('Double Wishbone|Double wishbone|double-wishbone|double wishbone|Double wish-bone', na=False), 'Front_Suspension'] = 'Double Wishbone Suspension'
car.loc[car['Front_Suspension'].str.contains('link|Link', na=False), 'Front_Suspension'] = 'Multi Link Suspension'
car.loc[car['Front_Suspension'].str.contains('Adaptive|adaptive', na=False), 'Front_Suspension'] = 'Adaptive Suspension'
car.loc[car['Front_Suspension'].str.contains('Leaf spring|leaf spring|Leaf Spring', na=False), 'Front_Suspension'] = 'Leaf Spring Suspension'
car.loc[car['Front_Suspension'].str.contains('Air|air|AIRMATIC', na=False), 'Front_Suspension'] = 'Air Suspension'
car.loc[car['Front_Suspension'].str.contains('Damper|damper|damping|CONTROL', na=False), 'Front_Suspension'] = 'Damper Suspension'
car.loc[car['Front_Suspension'].str.contains('Independent|independent', na=False), 'Front_Suspension'] = 'Independent Suspension'
car.loc[car['Front_Suspension'].str.contains('Double joint|Double-Joint', na=False), 'Front_Suspension'] = 'Double Joint Suspension'
car.loc[car['Front_Suspension'].str.contains('single joint ', na=False), 'Front_Suspension'] = 'Single Joint Suspension'
car.loc[~car['Front_Suspension'].str.contains('MacPherson|Double Wishbone|Multi Link|Adaptive|Leaf Spring|Air|Damper|Independent|Double', na=False), 'Front_Suspension'] = 'Aluminium Suspension'

"""Now, we examine the unique values in the updated '`Front_Suspension`' column of the '`car`' DataFrame after the standardization process."""

# Display unique values in the updated 'Front_Suspension' column of the 'car' DataFrame
car['Front_Suspension'].unique()

"""Here, we inspect the unique values in the '`Rear_Suspension`' column of the '`car`' DataFrame to understand the different rear suspension configurations recorded in the dataset."""

car['Rear_Suspension'].unique()                   # Display unique values in the 'Rear_Suspension' column of the 'car' DataFrame

"""This code updates the '`Rear_Suspension`' column in the '`car`' DataFrame, standardizing various rear suspension types for consistency and clarity."""

# Update 'Rear_Suspension' column in 'car' DataFrame with standardized suspension types
car.loc[car['Rear_Suspension'].str.contains('multi-link|multilink', case=False, na=False), 'Rear_Suspension'] = 'Multi-link Suspension'
car.loc[car['Rear_Suspension'].str.contains('torsion beam|torsion bar', case=False, na=False), 'Rear_Suspension'] = 'Torsion Beam Suspension'
car.loc[car['Rear_Suspension'].str.contains('double wishbone|wishbone', case=False, na=False), 'Rear_Suspension'] = 'Double Wishbone Suspension'
car.loc[car['Rear_Suspension'].str.contains('coil spring|coil-over|coilover', case=False, na=False), 'Rear_Suspension'] = 'Coil Spring Suspension'
car.loc[car['Rear_Suspension'].str.contains('independent|macpherson|mcpherson', case=False, na=False), 'Rear_Suspension'] = 'Independent Suspension'
car.loc[car['Rear_Suspension'].str.contains('leaf spring|leaf-sprung|leafsprung', case=False, na=False), 'Rear_Suspension'] = 'Leaf Spring Suspension'
car.loc[~car['Rear_Suspension'].str.contains('Multi-link|Torsion Beam|Double Wishbone|Coil Spring|Independent|Leaf Spring', case=False, na=False), 'Rear_Suspension'] = 'Other Suspension'

"""Now, we explore the unique values in the updated '`Rear_Suspension`' column of the '`car`' DataFrame after the standardization process."""

# Display unique values in the updated 'Rear_Suspension' column of the 'car' DataFrame
car['Rear_Suspension'].unique()

"""###11. Processing `Track` Datasets

Here, we show the first few rows of the '`Front_Track`' and '`Rear_Track`' columns from the '`car`' DataFrame for inspection.
"""

car[['Front_Track', 'Rear_Track']].head()       # Display the 'Front_Track' and 'Rear_Track' columns from the 'car' DataFrame

"""This code cleans and standardizes the '`Front_Track`' and '`Rear_Track`' columns in the '`car`' DataFrame, renaming columns to reflect units and converting them to float type for consistency."""

# Clean and standardize 'Front_Track' and 'Rear_Track' columns in 'car' DataFrame
car['Front_Track'] = car['Front_Track'].replace(r'\D', '', regex=True)
car['Rear_Track'] = car['Rear_Track'].replace(r'\D', '', regex=True)

# Rename columns to reflect units and data type
car.rename(columns={'Front_Track': 'Front_Track_mm','Rear_Track': 'Rear_Track_mm'}, inplace=True)

# Convert cleaned columns to float type
car['Front_Track_mm'] = car['Front_Track_mm'].astype(float)
car['Rear_Track_mm'] = car['Rear_Track_mm'].astype(float)

"""Here, we show the first few rows of the cleaned and standardized '`Front_Track_mm`' and '`Rear_Track_mm`' columns from the '`car`' DataFrame for inspection."""

# Display the cleaned and standardized 'Front_Track_mm' and 'Rear_Track_mm' columns from the 'car' DataFrame
car[['Front_Track_mm', 'Rear_Track_mm']].head()

"""###12. Processing `Tire` Datasets

This code removes spaces from the '`Front_Tyre_&_Rim`' column in the '`car`' DataFrame and displays unique values, ensuring consistent formatting.
"""

# Remove spaces from the 'Front_Tyre_&_Rim' column in 'car' DataFrame and display unique values
car['Front_Tyre_&_Rim'] = car['Front_Tyre_&_Rim'].str.replace(' ','',regex=False)
car['Front_Tyre_&_Rim'].unique()

"""This code **splits and extracts** information from the '`Front_Tyre_&_Rim`' column, then **cleans and replaces** specific values in the relevant columns ('`F_Tire_Width`', '`F_Tire_Aspect_Ratio`', '`F_Tire_Diameter`'). The cleaned columns are converted to float type for consistency"""

# Split and extract information from 'Front_Tyre_&_Rim' column, and clean relevant columns
car[['F_Tire_Width', 'F_Tire']] = car['Front_Tyre_&_Rim'].str.split('/', n=1, expand=True)
car[['F_Tire_Aspect_Ratio', 'F_Tire_Diameter']] = car['F_Tire'].str.split('R', n=1, expand=True)

f_drop = ['F_Tire']
car.drop(columns=f_drop, inplace=True)          # Drop the original 'F_Tire' column

# Clean and replace specific values in the extracted columns
car['F_Tire_Width'] = car['F_Tire_Width'].replace({'155R13LT':'155','(245':'245','R12':np.nan,'R16':np.nan,'43.66cm':np.nan,'P215':'215','P235':'235','145R12LT6PR':'145' , '195R15LT,8PRRadial':'195','21565R16':'215'})
car['F_Tire_Aspect_Ratio'] = car['F_Tire_Aspect_Ratio'].replace({'17"LightAlloyWheelsJCWTrackSpoke,Black':'43','35Z':'35','Z':'','40/20':'40','30Z':'30','40Z':'40','60/':'60','45Z':'45','60Z':'60','60V':'60','55Z':'55','155':np.nan,None:np.nan})
car['F_Tire_Diameter'] = car['F_Tire_Diameter'].replace({'15Steel':'15','18TubelessRadials':'18','F20':'20','1794Y':np.nan,None:np.nan})

# Convert the cleaned columns to float type
car['F_Tire_Width'] = car['F_Tire_Width'].astype(float)
car['F_Tire_Aspect_Ratio'] = car['F_Tire_Aspect_Ratio'].astype(float)
car['F_Tire_Diameter'] = car['F_Tire_Diameter'].astype(float)

"""Now, we explore the unique values in the cleaned '`F_Tire_Width`' column of the '`car`' DataFrame after the data cleaning and standardization process."""

car['F_Tire_Width'].unique()              # Display unique values in the cleaned 'F_Tire_Width' column of the 'car' DataFrame

"""Here, we examine the unique values in the cleaned '`F_Tire_Aspect_Ratio`' column of the '`car`' DataFrame after the data cleaning and standardization process."""

car['F_Tire_Aspect_Ratio'].unique()       # Display unique values in the cleaned 'F_Tire_Aspect_Ratio' column of the 'car' DataFrame

"""Now, we explore the unique values in the cleaned '`F_Tire_Diameter`' column of the '`car`' DataFrame after the data cleaning and standardization process."""

car['F_Tire_Diameter'].unique()           # Display unique values in the cleaned 'F_Tire_Diameter' column of the 'car' DataFrame

"""This code reorders and renames columns in the '`car`' DataFrame, placing '`F_Tire_Width`', '`F_Tire_Aspect_Ratio`', and '`F_Tire_Diameter`' in front for better organization. The original '`Front_Tyre_&_Rim`' column is dropped."""

# Reorder and rename columns in 'car' DataFrame for better organization
width = car.columns.get_loc('F_Tire_Width')
aspect = car.columns.get_loc('F_Tire_Aspect_Ratio')
diameter = car.columns.get_loc('F_Tire_Diameter')
front = car.columns.get_loc('Front_Tyre_&_Rim')

column_to_move = car.pop('F_Tire_Width')
car.insert(front, 'F_Tire_Width', column_to_move)         # Move the columns to the desired positions

column_to_move = car.pop('F_Tire_Aspect_Ratio')
car.insert(front, 'F_Tire_Aspect_Ratio', column_to_move)

column_to_move = car.pop('F_Tire_Diameter')
car.insert(front, 'F_Tire_Diameter', column_to_move)

# Drop the original 'Front_Tyre_&_Rim' column and rename the reordered columns
car.drop(columns=['Front_Tyre_&_Rim'], inplace=True)
car.rename(columns={'F_Tire_Width': 'F_Tire_Width_mm', 'F_Tire_Diameter': 'F_Tire_Diameter_inch'}, inplace=True)

"""This code removes spaces from the '`Rear_Tyre_&_Rim`' column in the '`car`' DataFrame and displays unique values, ensuring consistent formatting."""

# Remove spaces from the 'Rear_Tyre_&_Rim' column in 'car' DataFrame and display unique values
car['Rear_Tyre_&_Rim'] = car['Rear_Tyre_&_Rim'].str.replace(' ','', regex=False)
car['Rear_Tyre_&_Rim'].unique()

"""This code **splits and extracts** information from the '`Rear_Tyre_&_Rim`' column, then **cleans and replaces** specific values in the relevant columns ('`R_Tire_Width`', '`R_Tire_Aspect_Ratio`', '`R_Tire_Diameter`'). The cleaned columns are converted to float type for consistency."""

# Split and extract information from 'Rear_Tyre_&_Rim' column, and clean relevant columns
car[['R_Tire_Width', 'R_Tire']] = car['Rear_Tyre_&_Rim'].str.split('/', n=1, expand=True)
car[['R_Tire_Aspect_Ratio', 'R_Tire_Diameter']] = car['R_Tire'].str.split('R', n=1, expand=True)

r_drop = ['R_Tire']
car.drop(columns=r_drop, inplace=True)                # Drop the original 'R_Tire' column

# Clean and replace specific values in the extracted columns
car['R_Tire_Width'] = car['R_Tire_Width'].replace({'155R13LT':'155','(245':'245','R12':np.nan,'R16':np.nan,'43.66cm':np.nan,'P215':'215','P235':'235','145R12LT6PR':'145' , '195R15LT,8PRRadial':'195','21565R16':'215'})
car['R_Tire_Aspect_Ratio'] = car['R_Tire_Aspect_Ratio'].replace({'17"LightAlloyWheelsJCWTrackSpoke,Black':'43','35/20':'35','25Z':'25','50Z':'50','335':np.nan,'60/':'60','30Z':'30','60Z':'60','40Z':'40','60V':'60','35Z':'35','155':np.nan,None:np.nan})
car['R_Tire_Diameter'] = car['R_Tire_Diameter'].replace({None:np.nan,'1794Y':np.nan,'15Steel':'15','18TubelessRadials':'18','F20':'20'})

# Convert the cleaned columns to float type
car['R_Tire_Width'] = car['R_Tire_Width'].astype(float)
car['R_Tire_Aspect_Ratio'] = car['R_Tire_Aspect_Ratio'].astype(float)
car['R_Tire_Diameter'] = car['R_Tire_Diameter'].astype(float)

"""Now, we explore the unique values in the cleaned '`R_Tire_Width`' column of the '`car`' DataFrame after the data cleaning and standardization process."""

car['R_Tire_Width'].unique()        # Display unique values in the cleaned 'R_Tire_Width' column of the 'car' DataFrame

"""Here, we examine the unique values in the cleaned '`R_Tire_Aspect_Ratio`' column of the '`car`' DataFrame after the data cleaning and standardization process."""

car['R_Tire_Aspect_Ratio'].unique()             # Display unique values in the cleaned 'R_Tire_Aspect_Ratio' column of the 'car' DataFrame

"""Now, we explore the unique values in the cleaned '`R_Tire_Diameter`' column of the '`car`' DataFrame after the data cleaning and standardization process."""

car['R_Tire_Diameter'].unique()             # Display unique values in the cleaned 'R_Tire_Diameter' column of the 'car' DataFrame

"""This code reorders and renames columns in the '`car`' DataFrame, placing '`R_Tire_Width`', '`R_Tire_Aspect_Ratio`', and '`R_Tire_Diameter`' in front for better organization. The original '`Rear_Tyre_&_Rim`' column is dropped."""

# Reorder and rename columns in 'car' DataFrame for better organization
width = car.columns.get_loc('R_Tire_Width')
aspect = car.columns.get_loc('R_Tire_Aspect_Ratio')
diameter = car.columns.get_loc('R_Tire_Diameter')
rear = car.columns.get_loc('Rear_Tyre_&_Rim')

# Move the columns to the desired positions
column_to_move = car.pop('R_Tire_Width')
car.insert(rear, 'R_Tire_Width', column_to_move)

column_to_move = car.pop('R_Tire_Aspect_Ratio')
car.insert(rear, 'R_Tire_Aspect_Ratio', column_to_move)

column_to_move = car.pop('R_Tire_Diameter')
car.insert(rear, 'R_Tire_Diameter', column_to_move)

# Drop the original 'Rear_Tyre_&_Rim' column and rename the reordered columns
car.drop(columns=['Rear_Tyre_&_Rim'], inplace=True)
car.rename(columns={'R_Tire_Width': 'R_Tire_Width_mm', 'R_Tire_Diameter': 'R_Tire_Diameter_inch'}, inplace=True)

"""###13. Processing `Power` and `Torque` Datasets

Here, we show the first five rows of the '`Power`' column in the '`car`' DataFrame to provide a glimpse of the data.
"""

car['Power'].head()             # Display the first five rows of the 'Power' column in the 'car' DataFrame

"""This code splits and extracts information from the '`Power`' column into '`Power_PS`' (power in PS) and '`Power_RPM`' (power at RPM) columns, displaying the first five rows for reference."""

# Split and extract information from 'Power' column into 'Power_PS' and 'Power_RPM' columns
car[['Power_PS', 'Power_RPM']] = car['Power'].str.split('@', n=1, expand=True)
car[['Power_PS', 'Power_RPM']].head()

"""In this code, we clean the '`Power_PS`' column by removing non-numeric characters and converting it to **float** type. The unique values in the cleaned column are then displayed."""

# Clean and convert 'Power_PS' column to float type
car['Power_PS'] = car['Power_PS'].replace(r'[A-Za-z]', '', regex=True)
car['Power_PS'] = car['Power_PS'].astype(float)

# Display unique values in the cleaned 'Power_PS' column of the 'car' DataFrame
car['Power_PS'].unique()

"""In this code, the '`Power_RPM`' column is cleaned by removing non-numeric characters. Additionally, specific values are replaced, and the column is converted to float type. The unique values in the cleaned '`Power_RPM`' column are then displayed."""

# Clean and convert 'Power_RPM' column to float type
car['Power_RPM'] = car['Power_RPM'].replace(r'[A-Za-z]', '', regex=True)

# Replace specific values and convert to float type
car.loc[car['Power_RPM'].str.contains('-4', case=False, na=False), 'Power_RPM'] = '4000'
car.loc[car['Power_RPM'].str.contains('-6', case=False, na=False), 'Power_RPM'] = '6000'
car.loc[car['Power_RPM'].str.contains('-7', case=False, na=False), 'Power_RPM'] = '7000'

# Display unique values in the cleaned 'Power_RPM' column of the 'car' DataFrame
car['Power_RPM'] = car['Power_RPM'].astype(float)
car['Power_RPM'].unique()

"""This code reorders and renames columns in the '`car`' DataFrame, placing '`Power_PS`' and '`Power_RPM`' in front for better organization. The original '`Power`' column is dropped."""

# Reorder and rename columns in 'car' DataFrame for better organization
index_of_Power_RPM = car.columns.get_loc('Power_RPM')
index_of_Power_PS = car.columns.get_loc('Power_PS')
index_of_Power = car.columns.get_loc('Power')

# Move the columns to the desired positions
column_to_move = car.pop('Power_PS')
car.insert(index_of_Power, 'Power_PS', column_to_move)

column_to_move = car.pop('Power_RPM')
car.insert(index_of_Power, 'Power_RPM', column_to_move)

# Drop the original 'Power' column
car.drop(columns=['Power'], inplace=True)

# Display the first five rows of 'Power_PS' and 'Power_RPM' columns in 'car' DataFrame
car[['Power_PS', 'Power_RPM']].head()

"""Here, we show the first five rows of the '`Torque`' column in the '`car`' DataFrame to provide a glimpse of the data."""

car['Torque'].head()            # Display the first five rows of the 'Torque' column in the 'car' DataFrame

"""This code splits and extracts information from the '`Torque`' column into '`Torque_Nm`' (torque in Nm) and '`Torque_RPM`' (torque at RPM) columns, displaying the first five rows for reference."""

# Split and extract information from 'Torque' column into 'Torque_Nm' and 'Torque_RPM' columns
car[['Torque_Nm', 'Torque_RPM']] = car['Torque'].str.split('@', n=1, expand=True)
car[['Torque_Nm', 'Torque_RPM']].head()

"""In this code, the '`Torque_Nm`' column is cleaned by removing non-numeric characters and then converted to float type. The unique values in the cleaned '`Torque_Nm`' column are displayed."""

# Clean and convert 'Torque_Nm' column to float type
car['Torque_Nm'] = car['Torque_Nm'].replace(r'[A-Za-z]', '', regex=True)
car['Torque_Nm'] = car['Torque_Nm'].astype(float)

# Display unique values in the cleaned 'Torque_Nm' column of the 'car' DataFrame
car['Torque_Nm'].unique()

"""This code snippet cleans the '`Torque_RPM`' column by removing non-numeric characters, replaces specific values, and converts the column to float type. The unique values in the cleaned '`Torque_RPM`' column are then displayed."""

# Clean and convert 'Torque_RPM' column to float type
car['Torque_RPM'] = car['Torque_RPM'].replace(r'[A-Za-z]', '', regex=True)

# Replace specific values and convert to float type
car.loc[car['Torque_RPM'].str.contains('-1', case=False, na=False), 'Torque_RPM'] = '1000'
car.loc[car['Torque_RPM'].str.contains('-2', case=False, na=False), 'Torque_RPM'] = '2000'
car.loc[car['Torque_RPM'].str.contains('-3|- 3', case=False, na=False), 'Torque_RPM'] = '3000'
car.loc[car['Torque_RPM'].str.contains('-4|- 4', case=False, na=False), 'Torque_RPM'] = '4000'
car.loc[car['Torque_RPM'].str.contains('-5|- 5', case=False, na=False), 'Torque_RPM'] = '5000'
car.loc[car['Torque_RPM'].str.contains('-6', case=False, na=False), 'Torque_RPM'] = '6000'

car['Torque_RPM'] = car['Torque_RPM'].astype(float)

# Display unique values in the cleaned 'Torque_RPM' column of the 'car' DataFrame
car['Torque_RPM'].unique()

"""This code reorders and renames columns in the '`car`' DataFrame, placing '`Torque_Nm`' and '`Torque_RPM`' in front for better organization. The original '`Torque`' column is dropped."""

# Reorder and rename columns in 'car' DataFrame for better organization
index_of_Torque_RPM = car.columns.get_loc('Torque_RPM')
index_of_Torque_Nm = car.columns.get_loc('Torque_Nm')
index_of_Torque = car.columns.get_loc('Torque')

# Move the columns to the desired positions
column_to_move = car.pop('Torque_Nm')
car.insert(index_of_Torque, 'Torque_Nm', column_to_move)

column_to_move = car.pop('Torque_RPM')
car.insert(index_of_Torque, 'Torque_RPM', column_to_move)

# Drop the original 'Torque' column
car.drop(columns=['Torque'], inplace=True)

# Display the first five rows of 'Torque_Nm' and 'Torque_RPM' columns in 'car' DataFrame
car[['Torque_Nm', 'Torque_RPM']].head()

"""###14. Processing `Power_Steering`, `Power_Windows`, `Power_Seats` and `Keyless_Entry` Datasets

This code snippet displays the unique values in the '`Power_Steering`' column of the '`car`' DataFrame.
"""

car['Power_Steering'].unique()            # Display unique values in the 'Power_Steering' column of the 'car' DataFrame

"""In this code, values in the '`Power_Steering`' column are replaced for better categorization. The modified unique values in the '`Power_Steering`' column are then displayed."""

# Replace values in the 'Power_Steering' column for better categorization
car['Power_Steering'] = car['Power_Steering'].replace({'Electric Power, Hydraulic Power':'Electro-Hydraulic','Yes':'Undefined Powered',np.nan:'Non Powered'})

# Display unique values in the modified 'Power_Steering' column of the 'car' DataFrame
car['Power_Steering'].unique()

"""This code snippet displays the unique values in the '`Power_Windows`' column of the '`car`' DataFrame."""

car['Power_Windows'].unique()                 # Display unique values in the 'Power_Windows' column of the 'car' DataFrame

"""In this code, values in the '`Power_Windows`' column are replaced for better categorization. The modified unique values in the '`Power_Windows`' column are then displayed."""

# Replace values in the 'Power_Windows' column for better categorization
car['Power_Windows'] = car['Power_Windows'].replace({'Only Front Windows':'Front Windows',np.nan:'Non Powered'})

# Display unique values in the modified 'Power_Windows' column of the 'car' DataFrame
car['Power_Windows'].unique()

"""This code snippet displays the unique values in the '`Power_Seats`' column of the '`car`' DataFrame."""

car['Power_Seats'].unique()                   # Display unique values in the 'Power_Seats' column of the 'car' DataFrame

"""In this code, values in the '`Power_Seats`' column are modified for better categorization. The modified unique values in the '`Power_Seats`' column are then displayed"""

# Modify values in the 'Power_Seats' column for better categorization
car.loc[car['Power_Seats'].str.contains('Yes|Power', case=False, na=False), 'Power_Seats'] = 'Powered Seats'
car['Power_Seats'] = car['Power_Seats'].replace(np.nan,'Non Powered')

# Display unique values in the modified 'Power_Seats' column of the 'car' DataFrame
car['Power_Seats'].unique()

"""This code snippet displays the unique values in the '`Keyless_Entry`' column of the '`car`' DataFrame."""

car['Keyless_Entry'].unique()           # Display unique values in the 'Keyless_Entry' column of the 'car' DataFrame

"""Now the, values in the '`Keyless_Entry`' column are modified for better categorization. The modified unique values in the '`Keyless_Entry`' column are then displayed."""

# Modify values in the 'Keyless_Entry' column for better categorization
car.loc[car['Keyless_Entry'].str.contains('Yes|Key|Remote', case=False, na=False), 'Keyless_Entry'] = 'Yes'
car['Keyless_Entry'] = car['Keyless_Entry'].replace(np.nan,'No')

# Display unique values in the modified 'Keyless_Entry' column of the 'car' DataFrame
car['Keyless_Entry'].unique()

"""###15. Processing Other Features - Datasets

Now, we are displaying the unique values in the '`Odometer`' column of the '`car`' DataFrame.
"""

car['Odometer'].unique()            # Display unique values in the 'Odometer' column of the 'car' DataFrame

"""Now, we are modifying values in the '`Odometer`' column for better categorization, and displaying the unique values in the modified '`Odometer`' column of the '`car`' DataFrame."""

# Modify values in the 'Odometer' column for better categorization
car['Odometer'] = car['Odometer'].replace({'Digital, Analog':'Digi-Analog','Yes':'Unspecified'})

# Display unique values in the modified 'Odometer' column of the 'car' DataFrame
car['Odometer'].unique()

"""Now, we are displaying the unique values in the '`Speedometer`' column of the '`car`' DataFrame."""

car['Speedometer'].unique()         # Display unique values in the 'Speedometer' column of the 'car' DataFrame

"""Now, we are modifying values in the '`Speedometer`' column for better categorization and displaying the unique values in the modified '`Speedometer`' column of the '`car`' DataFrame."""

# Modify values in the 'Speedometer' column for better categorization
car['Speedometer'] = car['Speedometer'].replace({'Analog, Digital':'Digi-Analog','Digital, Analog':'Digi-Analog','Yes':'Unspecified'})

# Display unique values in the modified 'Speedometer' column of the 'car' DataFrame
car['Speedometer'].unique()

"""Now, we are displaying the unique values in the '`Tachometer`' column of the '`car`' DataFrame."""

car['Tachometer'].unique()                # Display unique values in the 'Tachometer' column of the 'car' DataFrame

"""Now, we are updating values in the '`Tachometer`' column for better categorization and displaying the unique values in the modified '`Tachometer`' column of the '`car`' DataFrame."""

# Update values in the 'Tachometer' column for better categorization
car.loc[car['Tachometer'].str.contains('Yes|Analog|Digital', case=False, na=False), 'Tachometer'] = 'Yes'
car.loc[car['Tachometer'].str.contains('Not', case=False, na=False), 'Tachometer'] = 'No'
car['Tachometer'] = car['Tachometer'].replace(np.nan,'No')

# Display unique values in the modified 'Tachometer' column of the 'car' DataFrame
car['Tachometer'].unique()

"""Now, we are displaying the value counts for the '`Tripmeter`' column in the '`car`' DataFrame."""

car['Tripmeter'].value_counts()       # Display value counts for the 'Tripmeter' column in the 'car' DataFrame

"""Now, we have updated the '`Tripmeter`' column by setting non-null values to '`Yes`' and replacing remaining `NaN` values with '`No`'. The updated value counts are displayed."""

# Update 'Tripmeter' column: If not null, set to 'Yes'; otherwise, set to 'No'
car['Tripmeter'] = np.where(car['Tripmeter'].notnull(), 'Yes', car['Tripmeter'])

# Replace remaining NaN values with 'No' in the 'Tripmeter' column
car['Tripmeter'] = car['Tripmeter'].replace(np.nan, 'No')

# Display updated value counts for the 'Tripmeter' column in the 'car' DataFrame
car['Tripmeter'].value_counts()

"""Now, we are randomly sampling 5 entries from the '`Wheelbase`' column in the '`car`' DataFrame to get an overview of its values."""

car['Wheelbase'].sample(5)        # Display a random sample of 5 entries from the 'Wheelbase' column in the 'car' DataFrame

"""Now, we have cleaned and converted the '`Wheelbase`' column to numerical values in millimeters, renaming it as '`Wheelbase_mm`' in the process."""

# Clean and convert the 'Wheelbase' column to numerical values in millimeters
car['Wheelbase'] = car['Wheelbase'].replace(r'\D', '', regex=True)
car.rename(columns={'Wheelbase': 'Wheelbase_mm'}, inplace=True)
car['Wheelbase_mm'] = car['Wheelbase_mm'].astype(float)

"""Now, we can see the unique values in the cleaned '`Wheelbase_mm`' column of the '`car`' DataFrame."""

car['Wheelbase_mm'].unique()        # Display unique values in the cleaned 'Wheelbase_mm' column of the 'car' DataFrame

"""Now, we have removed the '`Wheels_Size`' column from the '`car`' DataFrame ad we have earlier determined the wheelbase and tire size"""

car.drop(columns='Wheels_Size', inplace=True)             # Remove the 'Wheels_Size' column from the 'car' DataFrame

"""Now, we can see the unique values in the cleaned '`Basic_Warranty`' column of the '`car`' DataFrame."""

car['Basic_Warranty'].unique()                # Display unique values in the cleaned 'Basic_Warranty' column

"""This code snippet updates the '`Basic_Warranty`' column in the '`car`' DataFrame based on specified conditions, renames it to '`Basic_Warranty_years`', and converts the values to float."""

# Update the 'Basic_Warranty' column in the 'car' DataFrame based on the specified conditions
car.loc[car['Basic_Warranty'].str.contains('1 Year', na=False), 'Basic_Warranty'] = '1'
car.loc[car['Basic_Warranty'].str.contains('2 years|2 Years|24 months', na=False), 'Basic_Warranty'] = '2'
car.loc[car['Basic_Warranty'].str.contains('3 years|3 Years|3rd years', na=False), 'Basic_Warranty'] = '3'
car.loc[car['Basic_Warranty'].str.contains('4 years', na=False), 'Basic_Warranty'] = '4'
car.loc[car['Basic_Warranty'].str.contains('8 yrs', na=False), 'Basic_Warranty'] = '8'

# Rename the 'Basic_Warranty' column to 'Basic_Warranty_years' and convert to float
car.rename(columns={'Basic_Warranty': 'Basic_Warranty_years'}, inplace=True)
car['Basic_Warranty_years'] = car['Basic_Warranty_years'].astype(float)

"""This code snippet will show the value counts for the '`Basic_Warranty_years`' column in the '`car`' DataFrame, indicating how many occurrences there are for each unique value in that column."""

car['Basic_Warranty_years'].value_counts()          # Display the value counts for the 'Basic_Warranty_years' column in the 'car' DataFrame

"""This code snippet will show the unique values present in the '`Boot_Space`' column of the '`car`' DataFrame."""

car['Boot_Space'].unique()    # Display unique values in the 'Boot_Space' column of the 'car' DataFrame

"""This code snippet cleans and converts the '`Boot_Space`' column in the '`car`' DataFrame to a float type, handling a specific case in the data"""

# Clean and convert 'Boot_Space' column to float type
car['Boot_Space'] = car['Boot_Space'].replace('209(All3RowsUp).550(3rdRowFolded)&803(2ndRowand3rdRowFolded) litres',np.nan)
car['Boot_Space'] = car['Boot_Space'].replace(r'\D', '', regex=True)
car.rename(columns={'Boot_Space': 'Boot_Space_litres'}, inplace=True)
car['Boot_Space_litres'] = car['Boot_Space_litres'].astype(float)

"""Now, we can use this code snippet to display the unique values in the '`Boot_Space_litres`' column of the '`car`' DataFrame."""

car['Boot_Space_litres'].unique()                 # Display unique values in the 'Boot_Space_litres' column of the 'car' DataFrame

"""Now we have dropped the 'Extended_Warranty' column from the 'car' DataFrame as we no further require the warranty."""

car.drop(columns='Extended_Warranty', inplace=True)             # Drop the 'Extended_Warranty' column from the 'car' DataFrame

"""Now we will process the '`Minimum_Turning_Radius`' column in the '`car`' DataFrame."""

car['Minimum_Turning_Radius'].unique()        # Display unique values in the 'Minimum_Turning_Radius' column of the 'car' DataFrame

"""In this step, non-digit characters are removed from the '`Minimum_Turning_Radius`' column, the column is renamed to '`Minimum_Turning_Radius_meter`' for clarity, and the values are converted to float in the '`car`' DataFrame."""

# Removing non-digit characters from the 'Minimum_Turning_Radius' column
car['Minimum_Turning_Radius'] = car['Minimum_Turning_Radius'].replace(r'\D', '', regex=True)

# Renaming the column to provide a more descriptive name
car.rename(columns={'Minimum_Turning_Radius': 'Minimum_Turning_Radius_meter'}, inplace=True)

# Converting the values in 'Minimum_Turning_Radius_meter' to float data type
car['Minimum_Turning_Radius_meter'] = car['Minimum_Turning_Radius_meter'].astype(float)

"""# **Handling Null Values**

Dealing with the NULL values present over the dataset.

Now, we produce summary statistics for the numerical columns in the updated '`car`' DataFrame,
"""

# Generate descriptive statistics for numerical columns in the updated 'car' DataFrame
car.describe()

"""This code prints the data type of each column in the '`car`' DataFrame, providing a quick overview of the types of variables present in the dataset."""

# Display the data type of each column in the 'car' DataFrame
for i in car.columns:
  print(i ,'-------', car[i].dtype)

"""This code calculates the total number of missing values in the entire '`car`' DataFrame."""

car.isnull().sum().sum()          # Sum of all missing values in the 'car' DataFrame

"""In this code, missing values in numeric columns of the '`car`' DataFrame are imputed with the median of each respective column."""

# Impute missing values with the median for numeric columns in the 'car' DataFrame
numeric=["int32","float64"]

for j in car.columns:
    if car[j].dtype in numeric:
        if car[j].isnull().sum()>0:
            car[j]=car[j].fillna(car[j].median())

"""Here, we print the count of missing values in numeric columns of the '`car`' DataFrame, providing insights into the remaining missing values after the imputation process."""

# Display the count of missing values in numeric columns of the 'car' DataFrame
for j in car.columns:
    if car[j].dtype in numeric:
        print(j,'--------',car[j].isnull().sum())

"""This code calculates the total number of remaining missing values in the entire '`car`' DataFrame after the imputation process."""

car.isnull().sum().sum()      # Sum of all remaining missing values in the 'car' DataFrame

"""Here, we define a list named '`vital`' containing a subset of important columns selected from the '`car`' DataFrame. These columns are considered vital for analysis and understanding the key features of the dataset."""

# Selecting a subset of vital columns from the 'car' DataFrame
vital = ['Make', 'Model', 'Variant', 'Ex-Showroom_Price_INR', 'Drivetrain', 'Cylinder_Configuration',
 'Emission_Norm', 'Engine_Location', 'Fuel_System', 'Fuel_Type', 'Body_Type', 'Front_Brakes', 'Rear_Brakes',
 'Front_Suspension', 'Rear_Suspension', 'Power_Steering', 'Power_Windows', 'Power_Seats', 'Odometer', 'Speedometer',
 'Seats_Material', 'Type']

"""In this code, missing values in the vital columns of the '`car`' DataFrame are filled with the placeholder '`unspecified`' to handle any remaining null values."""

# Fill missing values in vital columns with 'unspecified' in the 'car' DataFrame
for i in vital:
    car[i]=car[i].fillna('unspecified')

"""This code calculates the total number of remaining missing values in the entire '`car`' DataFrame after filling the vital columns with '`unspecified`'."""

car.isnull().sum().sum()          # Sum of all remaining missing values in the 'car' DataFrame after filling with 'unspecified'

"""Here, we iterate through the columns of the '`car`' DataFrame and append non-numeric features that are not part of the vital columns to the '`features`' list."""

# Extract non-numeric features not included in the vital columns
features = []
for i in car.columns:
    if i not in vital:
        if car[i].dtype not in numeric:
            features.append(i)

"""Prints the first 5 non-numeric features from the '`features`' list, providing a glimpse of the selected non-numeric features."""

features[:5]      # Display the first 5 non-numeric features

"""In this code, non-numeric features in the '`car`' DataFrame are converted to binary indicators, where '`Yes`' indicates the presence of a value, and '`No`' indicates a missing value."""

# Convert non-numeric features to binary indicators ('Yes' or 'No') in the 'car' DataFrame
for k in features:
    car[k] = np.where(car[k].notnull(), 'Yes', car[k])
    car[k] = car[k].fillna('No')

"""This code calculates the total number of remaining missing values in the entire '`car`' DataFrame after converting non-numeric features to binary indicators ('`Yes`' or '`No`')."""

car.isnull().sum().sum()  # Sum of all remaining missing values in the 'car' DataFrame after converting to binary indicators

"""#**Viewing & Saving Clean Data**

Viewing the final and cleaned data, saving it into `.csv` format

Here, the column names in the '`car`' DataFrame are modified by replacing spaces with **underscores** and converting them to **lowercase** for consistency.
"""

car.columns = [col.replace(' ', '_').lower() for col in car.columns]    # Rename columns by replacing spaces with underscores and converting to lowercase

"""Now, we take a look at a random sample of 5 rows from the modified '`car`' DataFrame to observe the changes in column names."""

car.sample(5)                 # Display a random sample of 5 rows from the modified 'car' DataFrame

"""This code prints the data types of each column in the modified '`car`' DataFrame, providing an overview of the data after the column name modifications."""

print(car.dtypes)       # Display data types of each column in the modified 'car' DataFrame

"""Here, we print the total number of remaining missing values in the entire modified '`car`' DataFrame after the data preparation steps."""

print(car.isnull().sum().sum())               # Sum of all remaining missing values in the modified 'car' DataFrame

"""Now, we print the current shape of the modified '`car`' DataFrame, indicating the number of rows and columns after the data preparation steps"""

print(car.shape)            # Display the current shape (rows, columns) of the modified 'car' DataFrame

"""This code prints concise information about the modified '`car`' DataFrame, including **data types, non-null counts, and memory usage**."""

print(car.info())           # Display concise information about the modified 'car' DataFrame

"""Here, the modified '`car`' DataFrame is saved to a **CSV file** named '`car_data_cleaned.csv`' without including the index column."""

car.to_csv('car_data_cleaned.csv', index=False)         # Save the modified 'car' DataFrame to a CSV file named 'car_data_cleaned.csv'

"""#**Statistics & Data Vizualization**

## **Data Analysis**

### 1.1. Descriptive Numeric Analysis

This code generates descriptive statistics, such as **mean, standard deviation, minimum, and maximum values**, for numerical columns in the '`car`' DataFrame.
"""

# Generate descriptive statistics for numerical columns in the 'stores' DataFrame
car.describe()

"""**Observation:**<br>
Here we get a statistical data for all the numerics value such as the price, dimensions of body and tire, capacity, power and torque.

### 1.2. Descriptive Numeric Analysis

This code generates descriptive statistics for categorical columns in the '`car`' DataFrame, including **count, unique values, top value, and frequency**.
"""

# Generate descriptive statistics for categorical columns in the 'stores' DataFrame
car.describe(include=['object'])

"""**Observation:**<br>
This type of description shows the frequency of each column which is object, their frequency and the leader for every column.

### 2. Top Car Models

Here, we calculate the average `ex-showroom price` for each car model, group the data by `make and model`, and then display the top 5 car models based on the **highest average ex-showroom price.**
"""

# Find and display the top 5 car models based on the ex-showroom price
top_car_models = car.groupby(['make', 'model'])['ex-showroom_price_inr'].mean().sort_values(ascending=False).head(5)
print("Top Car Models:\n", top_car_models)

"""**Observation:**<br>
In India, the leading car Bugatti is a super sports car, and the other 4 are known for luxury. Maybe they were bought by Ambani, Adani and Tata XD

### 3. Cheapest Car Models

Here, we calculate the average `ex-showroom price` for each car `model`, group the data by `make and model`, and then display the 5 cheapest car models based on the **lowest average ex-showroom price.**
"""

# Find and display the cheap 5 car models based on the ex-showroom price
cheapest_car_models = car.groupby(['make', 'model'])['ex-showroom_price_inr'].mean().sort_values(ascending=True).head(5)
print("Top Car Models:\n", cheapest_car_models)

"""**Observation:**<br>
Bajaj Qute is a most pocket friendly car. <br> Omni is best known to kidnap people (or ambulance) XP. Nano Genx and Datsun are now obsolete. <br> However Alto is know popularly for affordable cab services.

### 4. Popular Fuel Types

In this step, we identify and display the **top 5 most** popular fuel types based on their count in the '`car`' DataFrame.
"""

# Find and display the most popular fuel types based on the count
popular_fuel_types = car['fuel_type'].value_counts().head(5).reset_index()
print("Popular Fuel Types:\n", popular_fuel_types)

"""**Observation:**<br>
Seems like people of India sticks with more Pterol and Diesel Variants. Howevver it is concerning as we really need to switch over more renewable source.

### 5. Seating Capacity Insights

Here, we analyze seating capacity characteristics by calculating the **average** `ex-showroom price` for each seating capacity category in the '`car`' DataFrame.
"""

# Explore seating capacity characteristics
seating_capacity_insights = car.groupby('seating_capacity')['ex-showroom_price_inr'].mean()
print("Seating Capacity Insights:\n", seating_capacity_insights)

"""**Observation:**<br>
2 Seater always means a sports car. so it will always be high. 16 seater seems like more suspicious, maybe its a Traveller

### 6. Fuel Efficiency Analysis

In this analysis, we calculate the average `ARAI certified mileage` for each fuel type in the '`car`' DataFrame to understand fuel efficiency characteristics.
"""

# Analyze fuel efficiency based on ARAI certified mileage
fuel_efficiency_analysis = car.groupby('fuel_type')['arai_certified_mileage_kmpl'].mean()
print("Fuel Efficiency Analysis:\n", fuel_efficiency_analysis)

"""**Observation:**<br>
Its a surprise that Indian Dads still stick with petrol or diesel for better mileage. <br> Rather they should shitch to CNG for better mileage.

### 7. Correlation Analysis

Here, we compute and showcase the correlation matrix between numerical columns in the '`car`' DataFrame, **providing insights** into the relationships between different numerical features.
"""

# Calculate and display the correlation matrix between numerical columns
car.corr()

"""**Observation:**<br>
Matrix showing the co-relation between the numeric columns

### 8. Outliers Detection

This code identifies and examines **outliers** in all numeric columns of the '`car`' DataFrame by comparing values that exceed the **mean plus 3 times the standard deviation**. It then prints the values of outliers for each numeric column.
"""

# Identify and examine outliers in all numeric columns
numeric_columns = car.select_dtypes(include=['number']).columns

outliers = {}
for column in numeric_columns:
    # Filter values where they exceed the mean plus 3 times the standard deviation
    column_outliers = car.loc[car[column] > car[column].mean() + 3 * car[column].std(), column].values
    outliers[column] = column_outliers

# Print values of outliers for each numeric column
for column, values in outliers.items():
    print(f"Values of Outliers in {column}:\n", values)

"""**Observation:**<br>
Some cars might have an outlying feature, but that doesn't mean they doesn't exit. <br> They exist! But they are special.

### 9. Average Price by Make

In this step, we calculate and display the `average ex-showroom price` for each car make in the '`car`' DataFrame, providing insights into pricing trends across different makes.
"""

# Calculate and display the average ex-showroom price for each car make
average_price_by_make = car.groupby('make')['ex-showroom_price_inr'].mean()
print("Average Ex-showroom Price by Make:\n", average_price_by_make)

"""**Observation:**<br>
This showcases the average price that a brand offers to a customer.

### 10. Price Segmentation

Reference: [Pd.Cut](https://www.geeksforgeeks.org/how-to-use-pandas-cut-and-qcut/)<br>
Reference: [Unstack](https://www.geeksforgeeks.org/pandas-groupby-unstack/)

Here, we define price ranges for segmentation based on ex-showroom prices, create a new column 'price_segment' in the 'car' DataFrame, and then calculate and display the average ex-showroom price for each car make within each price segment.
"""

# Define price ranges for segmentation
super_expensive_range = (car['ex-showroom_price_inr'] > 5000000)
expensive_range = ((car['ex-showroom_price_inr'] <= 5000000) & (car['ex-showroom_price_inr'] > 2000000))
affordable_range = (car['ex-showroom_price_inr'] <= 2000000)

# Create a new column 'price_segment' based on the defined ranges
car['price_segment'] = pd.cut(car['ex-showroom_price_inr'], bins=[0, 2000000, 5000000, float('inf')],
                              labels=['Affordable', 'Expensive', 'Super Expensive'], right=False)

# Calculate and display the average ex-showroom price for each car make within each price segment
car.groupby(['price_segment', 'make'])['ex-showroom_price_inr'].mean().unstack().transpose()

"""**Observation:**<br>
Call the Indian Dads! They need this, before they dream about buying super-expensive cars. This will help them classify their dreams.

### 11. Model manufactured by Each Maker

This code creates a new DataFrame, `unique_models_per_make`, that lists unique car `models` for each make. The models are sorted and presented as comma-separated strings. This provides a concise overview of distinct car models associated with each make.
"""

# Create a new DataFrame with unique models per make
unique_models_per_make = car.groupby('make')['model'].unique().apply(lambda x: ', '.join(sorted(x))).reset_index()

# Display the unique models per make
print("Unique Models per Make:\n", unique_models_per_make)

"""**Observation:**<br>
This showcases the different models that every car brand offers to customer.

### 12. Feature-Rich Cars

This code creates a '`num_features`' column in the '`car`' DataFrame, counting the '`Yes`' values across a list of car features. This allows for a concise **numerical representation** of the number of features in each car.
"""

# List of features (lowercased)
features = [
    'keyless_entry', 'tachometer', 'tripmeter', 'start_/_stop_button', '12v_power_outlet', 'audiosystem',
    'aux-in_compatibility', 'average_fuel_consumption', 'bluetooth', 'boot-lid_opener', 'cd_/_mp3_/_dvd_player',
    'central_locking', 'child_safety_locks', 'clock', 'cup_holders', 'distance_to_empty', 'door_pockets',
    'engine_malfunction_light', 'fm_radio', 'fuel-lid_opener', 'fuel_gauge', 'handbrake', 'instrument_console',
    'low_fuel_warning', 'multifunction_display', 'sun_visor', 'third_row_ac_vents', 'ventilation_system',
    'auto-dimming_rear-view_mirror', 'hill_assist', 'gear_indicator', 'engine_immobilizer', 'seat_back_pockets',
    'abs_(anti-lock_braking_system)', 'headlight_reminder', 'adjustable_headrests', 'gross_vehicle_weight', 'airbags',
    'door_ajar_warning', 'ebd_(electronic_brake-force_distribution)', 'fasten_seat_belt_warning', 'gear_shift_reminder',
    'adjustable_steering_column', 'parking_assistance', 'key_off_reminder', 'usb_compatibility', 'cigarette_lighter',
    'infotainment_screen', 'multifunction_steering_wheel', 'average_speed', 'eba_(electronic_brake_assist)',
    'seat_height_adjustment', 'navigation_system', 'second_row_ac_vents', 'rear_center_armrest', 'ipod_compatibility',
    'esp_(electronic_stability_program)', 'cooled_glove_box', 'turbocharger', 'isofix_(child-seat_mount)',
    'rain_sensing_wipers', 'leather_wrapped_steering', 'automatic_headlamps', 'asr_/_traction_control', 'cruise_control'
]

# Create a new column 'num_features' with the count of 'Yes' values for each row
car['num_features'] = car[features].apply(lambda row: row.eq('Yes').sum(), axis=1)

"""In this step, we identify and display the **top 20 cars** in the '`car`' DataFrame based on the number of features, showcasing cars with a higher number of features."""

# Find and display the top 20 cars with more features
top_cars_more_features = car.sort_values(by='num_features', ascending=False).head(20)[['make', 'model', 'ex-showroom_price_inr', 'num_features']]
print("Top 20 Cars with More Features:\n", top_cars_more_features)

"""**Observation:**<br>
Are you rich? Want more features in a car? Go for Jaguar Xj<br>
Else you can go for Skoda Superb!

### 13. Cars with Less Features

Here, we identify and display the last 5 cars in the '`car`' DataFrame based on the `number of features`, showcasing cars with a lower number of features
"""

# Find and display the last 5 cars with less features
cars_less_features = car.sort_values(by='num_features', ascending=False).tail(5)[['make', 'model', 'ex-showroom_price_inr', 'num_features']]
print("5 Cars with Less Features:\n", cars_less_features)

"""**Observation:**<br>
If you want to waste money with less features, regret buying Rolls Royce Cullinan. <br> Else buy Mahindra Bolero.

## **Data Vizualization: `Univariate`**

### 1. **Histogram**

Here, we create a side-by-side histogram subplot for the `distribution of ex-showroom prices` and the `count of features` in the '`car`' DataFrame. The first subplot uses a log scale for better visualization of ex-showroom prices.
"""

# Create a side-by-side histogram subplot for sales and days to ship
fig, axes = plt.subplots(1, 2, figsize=(14, 4))

# First subplot for sales distribution
log_bins = np.logspace(np.log10(car['ex-showroom_price_inr'].min()), np.log10(car['ex-showroom_price_inr'].max()), 20)
axes[0].hist(car['ex-showroom_price_inr'], bins=log_bins, color='skyblue', edgecolor='black')
axes[0].set_title('Distribution of Ex-showroom Prices')
axes[0].set_xlabel('Ex-showroom Price (INR)')
axes[0].set_ylabel('Frequency')
axes[0].set_xscale('log')  # Set x-axis to log scale

# Second subplot for the count of features
sns.histplot(car['num_features'], bins=30, color='lightgreen', edgecolor='black', ax=axes[1])
axes[1].set_title('Histogram of Features Count')
axes[1].set_xlabel('Number of Features')
axes[1].set_ylabel('Frequency')

# Adjust layout to prevent overlapping
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Plot 1 shows that the Indian car market is more focused on affordable range which is 10 Lacs.
2. Plot 2 shows that most of the Indian cars have more than 30 features in their car. Yes, India do want to get an industry ready modified and featured car.

### 2. **Bar Charts**

Reference: [.idmax()](https://stackoverflow.com/questions/46217537/choose-between-two-values-and-set-the-most-frequent-in-a-pandas-dataframe)

This code creates a side-by-side bar plot with two subplots. The first subplot shows the `count of car makes` to visualize the `diversity` of car makes. The second subplot displays the `count of variants` for the `top-diverse model` from each `make`.
"""

# Create a side-by-side bar plot for car makes and top-diverse models
fig, axes = plt.subplots(1, 2, figsize=(16, 5))

# First subplot for car makes
sns.countplot(data=car, x='make', palette='viridis', order=car['make'].value_counts().index, ax=axes[0])
axes[0].set_title('Count of Diversity of Car Makes')
axes[0].set_xlabel('Car Make')
axes[0].set_ylabel('Total Count they Offer')
axes[0].tick_params(axis='x', rotation=90)

# Identify the top-diverse model for each make
top_models_by_make = car.groupby('make')['model'].apply(lambda x: x.value_counts().idxmax())

# Filter the car DataFrame to include only the rows corresponding to the top-selling models
top_diverse_cars = car[car['model'].isin(top_models_by_make)]

# Second subplot for top-diverse models
sns.countplot(data=top_diverse_cars, x='model', order=top_diverse_cars['model'].value_counts().index, palette='viridis', ax=axes[1])
axes[1].set_title('Top-Diverse Model from Each Make')
axes[1].set_xlabel('Car Model')
axes[1].set_ylabel('Counts of Variants')
axes[1].tick_params(axis='x', rotation=90)

# Adjust layout to prevent overlapping
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. This was expected! Indian dad's trust is always Maruti Suzuki! Who's DC anyway? The one who created Tarzan the wonder car?
2. Well Never know Ranjit sir would offer so much variants in Nexon. Anyways Avanti is an overrated modified car for me.

Now we calculats the `counts` of car makes and price segments, then create a `stacked bar chart` using Plotly to visualize the distribution of makes across different price segments.
"""

# Calculate the counts of makes and price segments
make_counts = car.groupby(['make', 'price_segment']).size().reset_index(name='count')

# Sort the makes in descending order based on the total count
sorted_makes = make_counts.groupby('make')['count'].sum().sort_values(ascending=False).index

# Create a stacked bar chart using plotly
fig = px.bar(make_counts, x='make', y='count', color='price_segment', title='Counts of Makes by Price Segment',
             labels={'make': 'Make', 'count': 'Count', 'price_segment': 'Price Segment'}, height=500,
             category_orders={'make': sorted_makes})

# Customize the layout
fig.update_layout(xaxis=dict(tickangle=-45, tickmode='array', tickvals=list(range(len(sorted_makes))),
                             ticktext=sorted_makes))

# Show the chart
fig.show()

"""**Observation:**<br>
Well we can now see, why Indians prefer Maruti, Hyundai, Mahindra, Tata, Toyota and Honda! Its super affordable! Also we can see them everywhere on Indian roads.

Here, we define the `desired body types`, filter the DataFrame to include only those body types, and then create side-by-side bar charts for `fuel type` and the `distribution of desired body types`. The y-axis is displayed on a log scale for better visualization.
"""

# Define the desired body types
desired_body_types = ['Coupe', 'Crossover', 'Hatchback', 'MPV', 'MUV', 'Pick-up', 'Sedan', 'Sports', 'SUV']

# Filter the DataFrame to include only the desired body types
filtered_car = car[car['body_type'].isin(desired_body_types)]

# Create side-by-side bar charts for fuel type and body type distribution
fig, axes = plt.subplots(1, 2, figsize=(16, 4))

# Bar chart for fuel type distribution
sns.countplot(data=car, x='fuel_type',width = 0.5, order=car['fuel_type'].value_counts().index, palette='viridis', ax=axes[0])
axes[0].set_yscale('log')
axes[0].set_title('Count of Cars by Fuel Type')
axes[0].set_xlabel('Fuel Type')
axes[0].set_ylabel('Count (log scale)')

# Bar chart for filtered body type distribution
sns.countplot(data=filtered_car, x='body_type', order=filtered_car['body_type'].value_counts().index, palette='viridis', ax=axes[1])
axes[1].set_yscale('log')
axes[1].set_title('Count of Cars by Desired Body Types')
axes[1].set_xlabel('Body Type')
axes[1].set_ylabel('Count (log scale)')

# Adjust layout to prevent overlapping
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Petrol and diesel is still preferred in India by lot.
2. Nowadays there is hype of SUV and Sedan, people of India prefere more spacious car. I rather see more SUVs and sedans nowadays

### 3. **Box Plots**

Here, we create a 2x2 matrix of box plots for different features in the '`car`' DataFrame, showcasing the distribution and `variability of ex-showroom prices`, `ARAI certified mileage`, `number of cylinders`, and `number of doors`. The x-axis for ex-showroom prices is displayed on a log scale for better visualization.
"""

# Create a 2x2 matrix of box plots
fig, axes = plt.subplots(2, 2, figsize=(15, 10))

# Box plot for ex-showroom prices
sns.boxplot(data=car, x='ex-showroom_price_inr', color='lightblue', ax=axes[0, 0])
axes[0, 0].set_xscale('log')
axes[0, 0].set_title('Ex-showroom Prices')
axes[0, 0].set_xlabel('Ex-showroom Price (INR)')

# Box plot for ARAI certified mileage
sns.boxplot(data=car, x='arai_certified_mileage_kmpl', color='lightgreen', ax=axes[0, 1])
axes[0, 1].set_title('ARAI Certified Mileage (kmpl)')
axes[0, 1].set_xlabel('ARAI Certified Mileage (kmpl)')

# Box plot for cylinders
sns.boxplot(data=car, x='cylinders', color='lightcoral', ax=axes[1, 0])
axes[1, 0].set_title('Cylinders')
axes[1, 0].set_xlabel('Number of Cylinders')

# Box plot for doors
sns.boxplot(data=car, x='doors', color='lightskyblue', ax=axes[1, 1])
axes[1, 1].set_title('Doors')
axes[1, 1].set_xlabel('Number of Doors')

# Adjust layout
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Yes, prices of car, have extensive outliers depending of rich class of people buying super expensive sports or luxury cars.
2. An average car in India gives mileage of 17-22 kmpl.
3. Cylinders of Indian cars remain fixed and distributed.
4. Most car of India has 4 doors except the sports car having 2 doors.

### 4. **Pie Charts**

Reference: [Function](https://stackoverflow.com/questions/61283620/calling-pandas-apply-function-on-results-of-a-mask)
<br>In this function, we take a data series and a `threshold percentage` as inputs. The function calculates the **percentages of each category** in the series and creates **a mask to identify categories exceeding the specified threshold percentage**. Categories below the threshold are grouped into '`Others`,' and the resulting grouped series is returned.
"""

# Function to group small percentages into 'Other'
def group_small_percentages(data_series, threshold_percent=10):
    percentages = data_series.value_counts(normalize=True) * 100
    mask = percentages >= threshold_percent
    grouped_series = data_series.apply(lambda x: x if mask.get(x, False) else 'Others')
    return grouped_series

"""In this code, we remove '`unspecified`' values from each column in the '`car`' DataFrame and then create a 2x2 matrix of pie charts to visualize the distribution of `drivetrain types`, `emission norms`, `fuel types`, and `desired body types` in the market. The '`group_small_percentages`' function is utilized to handle small percentages and group them into 'Others' for better visualization."""

# Remove 'unspecified' values from each column
car_no_unspecified = car.replace('unspecified', np.nan).dropna()

# Create a 2x2 matrix for pie charts
plt.figure(figsize=(10, 8))

# Pie chart for Drivetrain
plt.subplot(2, 2, 1)
drivetrain_distribution = car_no_unspecified['drivetrain'].value_counts()
plt.pie(drivetrain_distribution, labels=drivetrain_distribution.index, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('crest'))
plt.title('Distribution of Drivetrain Types')
plt.legend(loc='lower left', fontsize='small')

# Pie chart for Emission Norm
plt.subplot(2, 2, 2)
emission_norm_distribution = car_no_unspecified['emission_norm'].value_counts()
plt.pie(emission_norm_distribution, labels=emission_norm_distribution.index, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('crest'))
plt.title('Distribution of Emission Norms')
plt.legend(loc='lower left', fontsize='small')

# Pie chart for Fuel Type
plt.subplot(2, 2, 3)
fuel_type_distribution = group_small_percentages(car_no_unspecified['fuel_type'])
plt.pie(fuel_type_distribution.value_counts(), labels=fuel_type_distribution.value_counts().index, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('crest'))
plt.title('Distribution of Fuel Types')
plt.legend(loc='lower left', fontsize='small')

# Pie chart for Desired Body Types
plt.subplot(2, 2, 4)
body_type_distribution = group_small_percentages(filtered_car['body_type'])
plt.pie(body_type_distribution.value_counts(), labels=body_type_distribution.value_counts().index, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('crest'))
plt.title('Distribution of Desired Body Types in the Market')
plt.legend(loc='lower left', fontsize='small')

plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Most cars in India are Forward and Rear wheel drive due to even terrain. 4 Wheel Drive is only required for long trekking such as Leh - Ladakh trip.
2. Most cars of India is BS4, which is more harmful for nature, however its preferred to use BS6.
3. Petrols and diesels are always first priority of Indian Dads!
4. India grows the hype of SUVs and Sedans, more than Hatchbacks.

Here, we are visualizing the distribution of the top 6 car `makes` and market-dominating car models using pie charts. The first subplot shows the `distribution of the top 6 car makes`, while the second subplot illustrates the `distribution of the top 6 market-dominating` car models.
"""

# Select the top 6 makes and market-dominating models based on counts
top_makes = car['make'].value_counts().head(6)
top_models = car['model'].value_counts().head(6)

# Create a 1x2 matrix of subplots
fig, axes = plt.subplots(1, 2, figsize=(15, 5))

# Plot the pie chart for top makes in the first subplot (axes[0])
axes[0].pie(top_makes, labels=top_makes.index, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('crest'))
axes[0].set_title('Distribution of Top 6 Car Makes')

# Plot the pie chart for top models in the second subplot (axes[1])
axes[1].pie(top_models, labels=top_models.index, autopct='%1.1f%%', startangle=90, colors=sns.color_palette('crest'))
axes[1].set_title('Distribution of Top 6 Market Dominating Car Models')

# Adjust layout for better spacing
plt.tight_layout()

# Show the plots
plt.show()

"""**Observation:**<br>
1. Maruti Suzuki and Hyundai shares more market in India
2. Tata Nexon didn't let us leave with a doubt of the toughest competitor in Indian Market

### 5. **Count Plots**

Here, we create a 3x3 matrix of subplots to visualize count plots for various categorical columns in the '`car`' DataFrame. Each subplot focuses on different aspects like `drivetrain`, `fuel type`, `cylinder configuration`, `engine location`, `number of doors`, `number of gears`, `transmission type`, and `body type`. The use of logarithmic scale on the y-axis enhances visibility.
"""

fig, axes = plt.subplots(3, 3, figsize=(15, 15))

# Count plot for drivetrain
sns.countplot(data=car_no_unspecified, x='drivetrain', ax=axes[0, 0], palette='viridis', order=car_no_unspecified['drivetrain'].value_counts().index, width=0.5)
axes[0, 0].set_title('Count of Cars by Drivetrain')
axes[0, 0].set_xlabel('Drivetrain')
axes[0, 0].set_yscale('log')

# Count plot for fuel type
sns.countplot(data=car_no_unspecified, x='fuel_type', ax=axes[0, 1], palette='viridis', order=car_no_unspecified['fuel_type'].value_counts().index, width=0.5)
axes[0, 1].set_title('Count of Cars by Fuel Type')
axes[0, 1].tick_params(axis='x', rotation=90)
axes[0, 1].set_xlabel('Fuel Type')
axes[0, 1].set_yscale('log')

# Count plot for cylinder configuration
sns.countplot(data=car_no_unspecified, x='cylinder_configuration', ax=axes[0, 2], palette='viridis', order=car_no_unspecified['cylinder_configuration'].value_counts().index, width=0.5)
axes[0, 2].set_title('Count of Cars by Cylinder Configuration')
axes[0, 2].set_xlabel('Cylinder Configuration')
axes[0, 2].set_yscale('log')

# Count plot for engine location
sns.countplot(data=car_no_unspecified, x='engine_location', ax=axes[1, 0], palette='viridis', order=car_no_unspecified['engine_location'].value_counts().index, width=0.5)
axes[1, 0].set_title('Count of Cars by Engine Location')
axes[1, 0].tick_params(axis='x', rotation=90)
axes[1, 0].set_xlabel('Engine Location')
axes[1, 0].set_yscale('log')

# Count plot for doors
sns.countplot(data=car_no_unspecified, x='doors', ax=axes[1, 1], palette='viridis', order=car_no_unspecified['doors'].value_counts().index, width=0.5)
axes[1, 1].set_title('Count of Cars by Number of Doors')
axes[1, 1].set_xlabel('Number of Doors')
axes[1, 1].set_yscale('log')

# Count plot for gears
sns.countplot(data=car_no_unspecified, x='gears', ax=axes[1, 2], palette='viridis', order=car_no_unspecified['gears'].value_counts().index, width=0.5)
axes[1, 2].set_title('Count of Cars by Number of Gears')
axes[1, 2].set_xlabel('Number of Gears')
axes[1, 2].set_yscale('log')

# Count plot for type
sns.countplot(data=car_no_unspecified, x='type', ax=axes[2, 0], palette='viridis', order=car_no_unspecified['type'].value_counts().index, width=0.5)
axes[2, 0].set_title('Count of Cars by Transmission Type')
axes[2, 0].set_xlabel('Transmission Type')
axes[2, 0].set_yscale('log')

# Count plot for body type
sns.countplot(data=filtered_car, x='body_type', ax=axes[2, 1], palette='viridis', order=filtered_car['body_type'].value_counts().index, width=0.5)
axes[2, 1].set_title('Count of Cars by Body Type')
axes[2, 1].tick_params(axis='x', rotation=90)
axes[2, 1].set_xlabel('Body Type')
axes[2, 1].set_yscale('log')

# Hide the empty subplot in the last row and last column
axes[2, 2].axis('off')

plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Due to even terrains (except pothholes), all cars are suitable to use Forward and Rear wheel drive.
2. Petrol and Diesel dominates Indian market
3. Most cars in India are required for city drive, they are rarely used for long drives. In-line is most suitable cylinder.
4. Almost every affordable car got their engine located in front.
5. 5 doors ? Really ? I think they are counting the trunk.
6. Most manual cars use 5 Geared transmission.
7. Slowly the automatic transmission is rising, which shows that Indian people are lazy to hit the clutch even.
8. Is SUV the new hatchback? Interesting!

## **Data Vizualization: `Bivariate`**

### 1. **Correlation Matrix**

Here, we select specific dimensions (`height`, `length`, `width`, `kerb weight`, and `ground clearance`) from the '`car`' DataFrame and calculate the correlation matrix. The resulting matrix shows the correlation coefficients between these dimensions.
"""

# Select the dimensions and calculate the correlation matrix
dimension_subset = car[['height_mm', 'length_mm', 'width_mm', 'kerb_weight_kg', 'ground_clearance_mm']].corr()

# Display the correlation matrix
dimension_subset

"""**Observation:**<br>
Dimesions of car that is really required

In this section, we choose specific columns related to `tire features` from the '`car`' DataFrame and compute the correlation matrix. The resulting matrix displays the correlation coefficients between these `tire-related dimensions`.
"""

# Select the specified columns and calculate the correlation matrix
correlation_matrix_tire = car[['front_track_mm', 'rear_track_mm', 'f_tire_diameter_inch', 'f_tire_aspect_ratio',
                               'f_tire_width_mm', 'r_tire_diameter_inch', 'r_tire_aspect_ratio', 'r_tire_width_mm']].corr()

# Display the correlation matrix
correlation_matrix_tire

"""**Observation:**<br>
Tires also matter for the roads full of potholes.

Here, we choose specific columns related to `power` and `torque` from the '`car`' DataFrame and compute the correlation matrix. The resulting matrix shows the correlation coefficients between these `power and torque`-related dimensions.
"""

# Select the specified columns and calculate the correlation matrix
correlation_matrix_power_torque = car[['power_rpm', 'power_ps', 'torque_rpm', 'torque_nm']].corr()

# Display the correlation matrix
correlation_matrix_power_torque

"""**Observation:**<br>
Indian Dads are less interested in this! Why did I find this even?<br> Its a more genz matter.

In this part, we choose specific columns related to `gears`, `doors`, and additional `features` from the '`car`' DataFrame and compute the correlation matrix.
"""

# Select the specified columns and calculate the correlation matrix
correlation_matrix_gears_doors_features = car[['gears', 'doors', 'num_features']].corr()

# Display the correlation matrix
correlation_matrix_gears_doors_features

"""**Observation:**<br>
Yes! Features, door and gears are the important factors for Indians.

### 2. **Scatter Plots**

Here, we create a scatter plot to visualize the relationship between the `ex-showroom price` and the `number of features for each car`. The x-axis is scaled logarithmically for better clarity.
"""

# Scatter plot of ex-showroom price vs. number of features
plt.figure(figsize=(14, 4))
plt.scatter(car['ex-showroom_price_inr'], car['num_features'], alpha=0.5, c='purple')
plt.title('Ex-showroom Price vs. Number of Features')
plt.xlabel('Ex-showroom Price (INR)')
plt.ylabel('Number of Features')
plt.xscale('log')
plt.grid(True)
plt.show()

"""**Observation:**<br>
Gives an informative insight as we see the number of features are growing upto 10 Lakhs, as the customers of India prefer more features in more affordable car.

The plots include comparisons between car `make` and `ex-showroom price`, `ARAI certified mileage` and `fuel type`, `fuel type` and `cylinder configuration`, and `fuel type` and `car type`. Legends and log scale on the y-axis are applied for better visualization.
"""

fig, axs = plt.subplots(2, 2, figsize=(14, 8))

# Scatter plot between car make and ex-showroom price
sns.scatterplot(x='make', y='ex-showroom_price_inr', data=car, palette='viridis', ax=axs[0, 0])
axs[0, 0].set_title('Car Make vs Ex-showroom Price')
axs[0, 0].set_xlabel('Car Make')
axs[0, 0].set_ylabel('Ex-showroom Price (INR)')
axs[0, 0].set_yscale('log')
axs[0, 0].tick_params(axis='x', rotation=90,labelsize=8)

# Scatter plot between ARAI certified mileage and fuel type
sns.scatterplot(x='arai_certified_mileage_kmpl', y='fuel_type', data=car, hue='fuel_type', palette='viridis', ax=axs[0, 1])
axs[0, 1].set_title('ARAI Certified Mileage vs Fuel Type')
axs[0, 1].set_xlabel('ARAI Certified Mileage (kmpl)')
axs[0, 1].set_ylabel('Fuel Type')
axs[0, 1].legend(title='Fuel Type', bbox_to_anchor=(1.05, 1), loc='upper left')

# Scatter plot between fuel type and cylinder configuration
sns.scatterplot(x='fuel_type', y='cylinder_configuration', data=car_no_unspecified, hue='fuel_type', palette='viridis', ax=axs[1, 0])
axs[1, 0].set_title('Fuel Type vs Cylinder Configuration')
axs[1, 0].set_xlabel('Fuel Type')
axs[1, 0].set_ylabel('Cylinder Configuration')
axs[1, 0].legend(title='Fuel Type')

# Scatter plot between fuel type and car type
sns.scatterplot(x='fuel_type', y='type', data=car_no_unspecified, hue='fuel_type', palette='viridis', ax=axs[1, 1])
axs[1, 1].set_title('Fuel Type vs Car Type')
axs[1, 1].set_xlabel('Fuel Type')
axs[1, 1].set_ylabel('Car Type')
axs[1, 1].legend(title='Fuel Type', bbox_to_anchor=(1.05, 1), loc='upper left')

plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Tata, Maruti, Hundai, Mahindra, Kia, Bajaj and Honda provides the afforadable cars focusing more customer.
2. CNG provides really good mileage as compare petrol and diesel.
3. In-line transmission supports all fuel type, making it more universal. V type is for sports
4. Never knew that manual isn't adjustable with electric. Also Automatic isn't adjustable with CNG.

### 3. **Pair Plots**

We create a pairplot to visualize relationships between selected numeric variables (`height`, `length`, `width`, `kerb weight`, and `ground clearance`) in the '`car`' DataFrame. The data is `subsampled` to improve **plot readability**. The title is added for clarity.
"""

# Pairplot for selected numeric variables
selected_numeric_variables = ['height_mm', 'length_mm', 'width_mm', 'kerb_weight_kg', 'ground_clearance_mm']
# Subsample the data
subsampled_data = car.sample(frac=0.2, random_state=42)

# Pairplot for selected numeric variables with subsampled data
sns.pairplot(subsampled_data[selected_numeric_variables])
plt.suptitle('Pairplot of Selected Numeric Variables (Subsampled Data)', y=1.02)
plt.show()

"""**Observation:**<br>
Pairplots give an insight of the dimensions that one looks before buying, to save taxes.

To visualize relationships between selected `power` and `torque` variables (`power RPM`, `power PS`, `torque RPM`, and `torque NM`) in the '`car`' DataFrame. The title is included for clarity.
"""

# Selected numeric variables
selected_power_torque_variables = ['power_rpm', 'power_ps', 'torque_rpm', 'torque_nm']

# Pairplot for selected power and torque variables
sns.pairplot(car[selected_power_torque_variables])
plt.suptitle('Pairplot of Power and Torque Variables', y=1.02)
plt.show()

"""**Observation:**<br>
Pairplot for the car lovers, to compare the power and torque then, buy the best car.

### 4. **Bar Charts**

Reference: [pd.cut](https://www.geeksforgeeks.org/pandas-cut-method-in-python/)

To explore the relationship between the `number of features`, `price segment`, and specific car `models`. The first chart displays the `count` of cars based on the number of `features and price segment`. The second and third charts showcase the `top 5 expensive` and `cheapest` car models along with the corresponding number of features. Legends, titles, and axis labels are provided for better interpretation.
"""

# Create bins for the number of features
feature_bins = [0, 10, 20, 30, 40, float('inf')]
feature_labels = ['0-10', '11-20', '21-30', '31-40', '41+']
car['feature_bins'] = pd.cut(car['num_features'], bins=feature_bins, labels=feature_labels, right=False)

# Find the top 5 unique car models with the highest ex-showroom prices
top_expensive_models = car.sort_values(by='ex-showroom_price_inr', ascending=False).drop_duplicates(subset='model').head(5)

# Find the top 5 unique car models with the lowest ex-showroom prices
top_cheapest_models = car.sort_values(by='ex-showroom_price_inr', ascending=True).drop_duplicates(subset='model').head(5)

# Create a 1x3 matrix of subplots
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Plot the first chart (Number of Features vs Price Segment)
sns.countplot(data=car, x='feature_bins', hue='price_segment', palette='viridis', ax=axes[0])
axes[0].set_title('Number of Features vs Price Segment')
axes[0].set_xlabel('Number of Features')
axes[0].set_ylabel('Count')

# Plot the second chart (Top 5 Expensive Car Models vs Number of Features)
sns.barplot(data=top_expensive_models, x='model', y='num_features', palette='viridis', width=0.5 , ax=axes[1])
axes[1].set_title('Top 5 Expensive Car Models vs Number of Features')
axes[1].set_xlabel('Car Model')
axes[1].set_ylabel('Number of Features')
axes[1].tick_params(axis='x', rotation=45)

# Plot the third chart (Top 5 Cheapest Car Models vs Number of Features)
sns.barplot(data=top_cheapest_models, x='model', y='num_features', palette='viridis', width=0.5, ax=axes[2])
axes[2].set_title('Top 5 Cheapest Car Models vs Number of Features')
axes[2].set_xlabel('Car Model')
axes[2].set_ylabel('Number of Features')
axes[2].tick_params(axis='x', rotation=45)

# Adjust layout
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Seems like that affordable cars provide more features, however super expensive car provides more power.
2. Chiron provides most feature and cullinan with least feature, being super expensive.
3. Nano Genx and Kwid are quiet impressive to provide such great features even being cheap.

Here, we sort the data by the mean mileage in descending order and create a bar chart to compare the `ARAI certified mileage` mean across different `fuel types`.
"""

# Sort the data by mean mileage in descending order
sorted_data = car.groupby('fuel_type')['arai_certified_mileage_kmpl'].mean().sort_values(ascending=False).index

# Bar chart with hue for Fuel Type vs Mileage mean
plt.figure(figsize=(14, 4))
sns.barplot(data=car, x='fuel_type', y='arai_certified_mileage_kmpl', hue='fuel_type', ci=False, palette='viridis', dodge=False, order=sorted_data, width=0.5)
plt.title('Fuel Type vs Mileage Mean')
plt.xlabel('Fuel Type')
plt.ylabel('ARAI Certified Mileage (kmpl)')
plt.legend(loc='upper right', bbox_to_anchor=(1.0, 1.0))
plt.show()

"""**Observation:**<br>
Some one please call and make Indian Dads undertand to buy CNG cars.

Now we explore the relationships between selected `body types`, `wheelbase`, `ARAI certified mileage`, and `ex-showroom price`. Three bar charts are created, each focusing on a different aspect and displaying the mean values.
"""

# Define the desired body types
desired_body_types = ['Coupe', 'Crossover', 'Hatchback', 'MPV', 'MUV', 'Pick-up', 'Sedan', 'Sports', 'SUV']

# Filter the DataFrame to include only the desired body types
filtered_car = car[car['body_type'].isin(desired_body_types)]

# Order the body types by mean wheelbase in descending order
order_body_types_wheelbase = filtered_car.groupby('body_type')['wheelbase_mm'].mean().sort_values(ascending=False).index

# Order the body types by mean ARAI Certified Mileage in descending order
order_body_types_mileage = filtered_car.groupby('body_type')['arai_certified_mileage_kmpl'].mean().sort_values(ascending=False).index

# Order the body types by mean Ex-showroom Price in descending order
order_body_types_price = filtered_car.groupby('body_type')['ex-showroom_price_inr'].mean().sort_values(ascending=False).index

# Create a 1x3 matrix for the subplots
fig, axes = plt.subplots(1, 3, figsize=(18, 6))

# Bar chart with hue for Wheel Size vs Body Type
sns.barplot(ax=axes[0], data=filtered_car, x='wheelbase_mm', y='body_type', hue='body_type', ci=False, palette='viridis', dodge=False, order=order_body_types_wheelbase)
axes[0].set_title('Wheel Size vs Body Type')
axes[0].set_xlabel('Wheelbase (mm)')
axes[0].set_ylabel('Body Type')
axes[0].legend(loc='lower right', bbox_to_anchor=(1.0, 0.0))

# Bar chart for Body Type vs ARAI Certified Mileage mean
sns.barplot(ax=axes[1], data=filtered_car, x='arai_certified_mileage_kmpl', y='body_type', hue='body_type', ci=False, palette='viridis', dodge=False, order=order_body_types_mileage)
axes[1].set_title('Body Type vs ARAI Certified Mileage Mean')
axes[1].set_xlabel('ARAI Certified Mileage (kmpl)')
axes[1].set_ylabel('Body Type')
axes[1].legend(loc='lower right', bbox_to_anchor=(1.0, 0.0))

# Bar chart for Body Type vs Ex-showroom Price mean with log scale on x-axis
sns.barplot(ax=axes[2], data=filtered_car, x='ex-showroom_price_inr', y='body_type',hue='body_type', ci=False, palette='viridis', dodge=False, order=order_body_types_price)
axes[2].set_xscale('log')
axes[2].set_title('Body Type vs Ex-showroom Price Mean')
axes[2].set_xlabel('Ex-showroom Price (INR)')
axes[2].set_ylabel('Body Type')
axes[2].legend(loc='lower right', bbox_to_anchor=(1.0, 0.0))

# Adjust layout to prevent clipping of titles
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Hatch back, Crossover and MPV is used for comfort/daily riding, however sport and SUV and pickup are heavy duty cars, that require more grip on road.
2. Sports having fastest engine, consumes fiul faster as compared to crossover being used for comfort ride.
3. Sports car having costliest engine tends to be more expensive.

### 5. **Heatmaps**

Here, we choose specific `dimensions` from the '`car`' DataFrame and compute the correlation matrix. The resulting heatmap visually represents the correlation coefficients between these dimension variables.
"""

# Select the dimensions and calculate the correlation matrix
dimension_subset = car[['height_mm', 'length_mm', 'width_mm', 'kerb_weight_kg', 'ground_clearance_mm']].corr()

# Create a heatmap for the correlation matrix
plt.figure(figsize=(8, 6))
sns.heatmap(dimension_subset, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Heatmap for Dimension Variables')
plt.show()

"""**Observation:**<br>
Dimesions of car that is really required

Now we focus on specific `tire-related variables` by selecting columns from the '`car`' DataFrame. The resulting heatmap illustrates the correlation coefficients among these tire-related dimensions, providing insights into their relationships.
"""

# Select the specified columns and calculate the correlation matrix
correlation_matrix_tire = car[['front_track_mm', 'rear_track_mm', 'f_tire_diameter_inch', 'f_tire_aspect_ratio',
                               'f_tire_width_mm', 'r_tire_diameter_inch', 'r_tire_aspect_ratio', 'r_tire_width_mm']].corr()

# Create a heatmap for the correlation matrix
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix_tire, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Heatmap for Tire-related Variables')
plt.show()

"""**Observation:**<br>
Tires also matter for the roads full of potholes.
"""

# Select the specified columns and calculate the correlation matrix
correlation_matrix_power_torque = car[['power_rpm', 'power_ps', 'torque_rpm', 'torque_nm']].corr()

# Create a heatmap for the correlation matrix
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix_power_torque, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Heatmap for Power and Torque Variables')
plt.show()

"""**Observation:**<br>
Indian Dads are less interested in this! Why did I find this even?<br> Its a more genz matter.

In this section, we focus on specific `power` and `torque` variables by selecting columns from the '`car`' DataFrame. The resulting heatmap illustrates the correlation coefficients among these variables, providing insights into their relationships.
"""

# Select the specified columns and calculate the correlation matrix
correlation_matrix_gears_doors_features = car[['gears', 'doors', 'num_features']].corr()

# Create a heatmap for the correlation matrix
plt.figure(figsize=(6, 4))
sns.heatmap(correlation_matrix_gears_doors_features, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Heatmap for Gears, Doors, and Num Features')
plt.show()

"""**Observation:**<br>
Yes! Features, door and gears are the important factors for Indians.

### 6. **Joint Plots**

Now we explore the relationships between the logarithm of `ex-showroom price`, `ARAI certified mileage`, and `body type` for the `desired body types`. The joint plot visualizes these correlations.
"""

# Define the desired body types
desired_body_types = ['Coupe', 'Crossover', 'Hatchback', 'MPV', 'MUV', 'Pick-up', 'Sedan', 'Sports', 'SUV']

# Filter the DataFrame to include only the desired body types
filtered_car = car[car['body_type'].isin(desired_body_types)]

# Joint plot for Price vs Mileage vs Body type
plt.figure(figsize=(8, 6))
filtered_car['log_price'] = np.log1p(filtered_car['ex-showroom_price_inr'])

joint_plot = sns.jointplot(data=filtered_car, x='log_price', y='arai_certified_mileage_kmpl', hue='body_type', height=8)
joint_plot.set_axis_labels('Log(Ex-showroom Price) INR', 'ARAI Certified Mileage (kmpl)')
joint_plot.fig.suptitle('Joint Plot for Log(Price) vs Mileage vs Body Type', y=1.02)
plt.show()

# Remove the temporary log_price column
filtered_car.drop('log_price', axis=1, inplace=True)

"""**Observation:**<br>
Gives a brief idea that bigger bodytype consumes more fuel.

Here, we generate a joint plot to explore the relationships between car `length` and `width`, considering different `fuel types`. The plot provides insights into how these dimensions vary across various fuel types.
"""

# Joint plot for Length vs Width vs Fuel type
plt.figure(figsize=(12, 8))

joint_plot = sns.jointplot(data=car, x='length_mm', y='width_mm', hue='fuel_type', height=8)
joint_plot.set_axis_labels('Length (mm)', 'Width (mm)')
joint_plot.fig.suptitle('Joint Plot for Length vs Width vs Fuel Type', y=1.02)
plt.show()

"""**Observation:**<br>
Gives synopsis about the dimension that requires to carry various types of fuel.

### 7. **Box Plots**

Here, we use a 2x2 matrix of subplots to **compare different aspects** of car data. We explore `affordability` vs `price`, `fuel type` vs `mileage`, `body type` vs `doors`, and `wheel size` vs `minimum turning radius`.
"""

# Create a 2x2 matrix of subplots
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(16, 12))

desired_body_types = ['Coupe', 'Crossover', 'Hatchback', 'MPV', 'MUV', 'Pick-up', 'Sedan', 'Sports', 'SUV']

# Filter the DataFrame to include only the desired body types
filtered_car = car[car['body_type'].isin(desired_body_types)]

# Order the body types by mean wheelbase in descending order
order_body_types_wheelbase = filtered_car.groupby('body_type')['wheelbase_mm'].mean().sort_values(ascending=False).index

# 1. Affordable vs Price (in log)
sns.boxplot(data=car, x='price_segment', y=np.log1p(car['ex-showroom_price_inr']), hue='price_segment', palette='viridis', dodge=False, ax=axes[0, 0])
axes[0, 0].set_title('Affordable vs Price (in log)')
axes[0, 0].set_xlabel('Affordability')
axes[0, 0].set_ylabel('Log(Ex-showroom Price)')

# 2. Fuel Type vs Mileage
sns.boxplot(data=car, x='fuel_type', y='arai_certified_mileage_kmpl', hue='fuel_type', palette='viridis', dodge=False, ax=axes[0, 1])
axes[0, 1].set_title('Fuel Type vs Mileage')
axes[0, 1].set_xlabel('Fuel Type')
axes[0, 1].set_ylabel('ARAI Certified Mileage (kmpl)')

# 3. Body Type vs Doors (corrected line)
sns.boxplot(data=filtered_car, x='body_type', y='doors', hue='body_type', palette='viridis', dodge=False, ax=axes[1, 0])
axes[1, 0].set_title('Body Type vs Doors')
axes[1, 0].set_xlabel('Body Type')
axes[1, 0].set_ylabel('Number of Doors')

# 4. Wheel Size vs minimum_turning_radius_meter (with y-axis in log scale)
sns.boxplot(data=car, x='f_tire_diameter_inch', y='minimum_turning_radius_meter', hue='f_tire_diameter_inch', palette='viridis', dodge=False, ax=axes[1, 1])
axes[1, 1].set_title('Wheel Size vs Minimum Turning Radius (meters)')
axes[1, 1].set_xlabel('Front Tire Diameter (inch)')
axes[1, 1].set_ylabel('Minimum Turning Radius (meters)')
axes[1, 1].set_yscale('log')

# Adjust layout for better spacing
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. Price segment provide crisp data about the affordability of any car.
2. All segments of fuel type tend to have same mileage. (less outliers)
3. Number of doors are more or less same for every bodytype car in India, however there are 4 door super cars along with 2 door super cars as well.
4. Tire size seems to have same turning radius except for some outliers.

### 8. **Categorical Plots**

Here, we use a 3x2 matrix of subplots to display categorical plots. The plots include counts of cars by `body type`, `number of doors`, `number of gears`, `affordability` vs `price`, `fuel type`, and `engine type`.
"""

# Create a 3x2 matrix for categorical plots
fig, axes = plt.subplots(3, 2, figsize=(15, 15))

desired_body_types = ['Coupe', 'Crossover', 'Hatchback', 'MPV', 'MUV', 'Pick-up', 'Sedan', 'Sports', 'SUV']

# Filter the DataFrame to include only the desired body types
filtered_car = car[car['body_type'].isin(desired_body_types)]

# Order the body types by mean count in descending order
order_body_types_count = filtered_car['body_type'].value_counts().sort_values(ascending=False).index

# Plot 1: Body Type
sns.countplot(data=filtered_car, x='body_type', palette='viridis', order=order_body_types_count, width=0.5, ax=axes[0, 0])
axes[0, 0].set_title('Count of Cars by Body Type')
axes[0, 0].set_xlabel('Body Type')
axes[0, 0].set_ylabel('Count')

# Plot 2: Doors
sns.countplot(data=car, x='doors', palette='viridis', order=car['doors'].value_counts().sort_values(ascending=False).index, width=0.5, ax=axes[0, 1])
axes[0, 1].set_title('Count of Cars by Number of Doors')
axes[0, 1].set_xlabel('Number of Doors')
axes[0, 1].set_ylabel('Count')
axes[0, 1].set_yscale('log')

# Plot 3: Gears
sns.countplot(data=car, x='gears', palette='viridis', order=car['gears'].value_counts().sort_values(ascending=False).index, width=0.5, ax=axes[1, 0])
axes[1, 0].set_title('Count of Cars by Number of Gears')
axes[1, 0].set_xlabel('Number of Gears')
axes[1, 0].set_ylabel('Count')
axes[1, 0].set_yscale('log')

# Plot 4: Affordability vs Price
sns.countplot(data=car, x='price_segment', order=car['price_segment'].value_counts().sort_values(ascending=False).index, width=0.5, palette='viridis', ax=axes[1, 1])
axes[1, 1].set_title('Count of Cars by Affordability')
axes[1, 1].set_xlabel('Affordability')
axes[1, 1].set_ylabel('Count')
axes[1, 1].set_yscale('log')

# Plot 5: Fuel Type
sns.countplot(data=car, x='fuel_type', palette='viridis', order=car['fuel_type'].value_counts().sort_values(ascending=False).index, width=0.5, ax=axes[2, 0])
axes[2, 0].set_title('Count of Cars by Fuel Type')
axes[2, 0].set_xlabel('Fuel Type')
axes[2, 0].set_ylabel('Count')
axes[2, 0].set_yscale('log')

# Plot 6: Engine Type
sns.countplot(data=car_no_unspecified, x='cylinder_configuration', palette='viridis', order=car_no_unspecified['cylinder_configuration'].value_counts().sort_values(ascending=False).index, width=0.5, ax=axes[2, 1])
axes[2, 1].set_title('Count of Cars by Engine Type')
axes[2, 1].set_xlabel('Engine Type')
axes[2, 1].set_ylabel('Count')
axes[2, 1].set_yscale('log')

# Adjust layout
plt.tight_layout()
plt.show()

"""**Observation:**<br>
1. OK! I understand SUV is more in India. Pick up is merely there in India.
2. Most Indian cars have 5 doors.
3. Indians loveeeeeee 5 gear manual than their car!
4. Indian market is booming with affordable cars.
5. Ok I understand, we need to become Indian Dads to make CNG popular.
6. In-line is most affordable and popular type in India

### 9. **Violin Plots**

This code generates a Violin Plot to visualize the distribution of `ex-showroom prices` for the `top 5 car makes` based on **average prices**.
"""

# Get the top 5 car makes based on average ex-showroom price
top_5_makes = car.groupby('make')['ex-showroom_price_inr'].mean().sort_values(ascending=False).head(5).index

# Filter the dataset for the top 5 makes
top_5_car_makes_data = car[car['make'].isin(top_5_makes)]

# Create a Violin Plot with y-axis limit
plt.figure(figsize=(15, 5))
sns.violinplot(data=top_5_car_makes_data, x='make', y='ex-showroom_price_inr', palette='viridis')
plt.title('Violin Plot of Ex-showroom Prices for Top 5 Car Makes')
plt.xlabel('Car Make')
plt.ylabel('Ex-showroom Price (INR)')
plt.show()

"""**Observation:**<br>
Well, Lamborghini has more diverse variants than bugatti being more diverse in pricing. <br> Why am I making it? I don't even have the money to buy my own cycle.

Violin Plot to visualize the distribution of `ARAI certified mileage` for different `fuel types`. The plot provides insights into the mileage distribution and helps in comparing the **fuel efficiency** of various fuel types.
"""

# Create a Violin Plot for Fuel Type vs Mileage
plt.figure(figsize=(12, 8))
sns.violinplot(data=car, x='fuel_type', y='arai_certified_mileage_kmpl', palette='viridis')
plt.title('Violin Plot of ARAI Certified Mileage by Fuel Type')
plt.xlabel('Fuel Type')
plt.ylabel('ARAI Certified Mileage (kmpl)')
plt.show()

"""**Observation:**<br>
CNG Provides more mileage range, Petrol and Diesel are providing less mileage ranges

### 10. **Stacked Bar Charts**

We sort the fuel types in **descending order** and create a stacked bar chart illustrating the distribution of `price segments` across different `fuel types`. The bars are sorted in decreasing order based on their total count.
"""

# Sort fuel types in descending order
sorted_fuel_types = sorted(car['fuel_type'].unique(), reverse=True)

# Create a stacked bar chart for Price Segment vs Fuel Type using Plotly
fig = px.histogram(car, x='fuel_type', color='price_segment', barmode='stack',
                   category_orders={'fuel_type': sorted_fuel_types},
                   labels={'fuel_type': 'Fuel Type', 'price_segment': 'Price Segment'},
                   title='Price Segment Distribution by Fuel Type')


fig.update_layout(xaxis_title='Fuel Type', yaxis_title='Count (log scale)', legend_title='Price Segment', yaxis_type="log")
# Sort bars in decreasing order
fig.update_xaxes(categoryorder='total descending')

fig.show()

"""**Observation:**<br>
Hybrid cars are super expensive everytime. Petrol and Diesel are more focused to be pocket friendly

We filter the dataset for `desired body types` and create a stacked bar chart to represent the `distribution of car makes` within these body types. The chart provides insights into the variety of car makes present in the specified body types.
"""

# Filter the dataset for desired body types
filtered_car = car[car['body_type'].isin(['Coupe', 'Crossover', 'Hatchback', 'MPV', 'MUV', 'Pick-up', 'Sedan', 'Sports', 'SUV'])]

# Create a stacked bar chart for Make vs Desired Body Types using Plotly
fig = px.histogram(filtered_car, x='make', color='body_type', barmode='stack',
                   category_orders={'make': sorted(filtered_car['make'].unique(), reverse=True)},
                   labels={'make': 'Make', 'body_type': 'Body Type'},
                   title='Make Distribution by Desired Body Types')
fig.update_layout(xaxis_title='Make', yaxis_title='Count', legend_title='Body Type')
fig.update_xaxes(tickangle=45, tickmode='array', tickvals=filtered_car['make'].unique())
fig.show()

"""**Observation:**<br>
Maruti, Mahindra and Hyundai provides extensive number of Body type cars to Indian Market.

Here, we filter out '`unspecified`' values from the '`cylinder_configuration`' column and create a stacked bar chart. The chart depicts the `distribution of fuel types` across different cylinder configurations, providing insights into the variety of engines in the dataset.
"""

# Filter out 'unspecified' values from cylinder_configuration
filtered_car = car[car['cylinder_configuration'] != 'unspecified']

# Sort fuel types in descending order
sorted_fuel_types = sorted(filtered_car['fuel_type'].unique(), reverse=True)

# Create a stacked bar chart for Fuel Type vs Cylinder using Plotly
fig = px.histogram(filtered_car, x='fuel_type', color='cylinder_configuration', barmode='stack',
                   category_orders={'fuel_type': sorted_fuel_types},
                   labels={'fuel_type': 'Fuel Type', 'cylinder_configuration': 'Cylinder Configuration'},
                   title='Fuel Type Distribution by Cylinder Configuration')


fig.update_layout(xaxis_title='Fuel Type', yaxis_title='Count (log scale)', legend_title='Cylinder Configuration', yaxis_type="log")
# Sort bars in decreasing order
fig.update_xaxes(categoryorder='total descending')

fig.show()

"""**Observation:**<br>
Petrol is the only fuel type that can run on all 4 cylinder types.

Dropping the extra columns generated during the process of visualization.
"""

# Drop 'feature_bins' and 'log_price' columns
car = car.drop(['feature_bins'], axis=1)
car